static GAME_OVER: bool;
static PLAYER_POSITION: Position;
const PLAYER_WIDTH: f64 = 16.0;
const PLAYER_HEIGHT: f64 = 16.0;
static PLAYER_FACING_LEFT: bool;
static PLAYER_MOVED_ON_LAST_FRAME: bool;
const TILE_WIDTH: f64 = 16.0;
const TILE_HEIGHT: f64 = 16.0;
static JUMP_SPEED: f64;
const TERMINAL_VELOCITY: f64 = 3.5;
static JUMP_STATE: JumpState;
static RNG: u64 = 0;
static SCORE_BUF: [u8; 10];
static SCORE: u32;

static DOING_DOOR: bool = false;

// Timers
static TIME_ALIVE: u64;
static TIME_DEAD: u64;
static TIME_DOING_DOOR: u64;

static LAST_GAMEPAD: u8;
// Guaranteed to have left-right exits.
static HALLWAY_ROOMS: [[Tile; 100]; 5];
// Guaranteed to have top entry and left-right exit.
static LANDING_ROOMS: [[Tile; 100]; 5];
// Guaranteed to have a downward exit and left-right exit.
static DROP_ROOMS: [[Tile; 100]; 7];
// No guarantees on exit.
static BONUS_ROOMS: [[Tile; 100]; 1];

static TILES: [Tile; 1600];

const CAMERAS: [Position; 16] = [
   // center of the first square, etc
   Position { x: 80.0, y: 80.0 },
   Position { x: 240.0, y: 80.0 },
   Position { x: 400.0, y: 80.0 },
   Position { x: 560.0, y: 80.0 },
   Position { x: 80.0, y: 240.0 },
   Position { x: 240.0, y: 240.0 },
   Position { x: 400.0, y: 240.0 },
   Position { x: 560.0, y: 240.0 },
   Position { x: 80.0, y: 400.0 },
   Position { x: 240.0, y: 400.0 },
   Position { x: 400.0, y: 400.0 },
   Position { x: 560.0, y: 400.0 },
   Position { x: 80.0, y: 560.0 },
   Position { x: 240.0, y: 560.0 },
   Position { x: 400.0, y: 560.0 },
   Position { x: 560.0, y: 560.0 },
];

struct Position {
   x: f64,
   y: f64,
}

enum Tile {
   Wall,
   Spike,
   Air,
   Coin,
   Door,
}

enum JumpState {
   Standing,
   Jumping,
   Falling,
}

proc dist(position_1: Position, position_2: Position) -> f64 {
   let x_diff = position_1.x - position_2.x;
   let y_diff = position_1.y - position_2.y;
   return sqrt((x_diff * x_diff) + (y_diff * y_diff));
}

proc rand() -> u64 {
   RNG = RNG ^ (RNG << 13);
   RNG = RNG ^ (RNG >> 7);
   RNG = RNG ^ (RNG << 17);
   return RNG;
}

proc rand_range(rand_min: u64, rand_max: u64) -> u64 {
   return rand() % (rand_max + 1 - rand_min) + rand_min;
}

proc one_in(x: u64) -> bool {
   return rand_range(0, x - 1) == 0;
}

proc rectangles_collide(x1: f64, y1: f64, width1: f64, height1: f64, x2: f64, y2: f64, width2: f64, height2: f64) -> bool {
   return
      (x1 < x2 + width2) &
      (x1 + width1 > x2) &
      (y1 < y2 + height2) &
      (height1 + y1 > y2);
}

proc segment_v_segment(x1: f64, y1: f64, x2: f64, y2: f64, x3: f64, y3: f64, x4: f64, y4: f64) -> bool {
   let dx1 = x2 - x1;
   let dy1 = y2 - y1;
   let dx2 = x4 - x3;
   let dy2 = y4 - y3;
   let dx3 = x1 - x3;
   let dy3 = y1 - y3;
   let d = dx1*dy2 - dy1*dx2;
   if d == 0.0 {
      return false;
   }
   let t1 = (dx2*dy3 - dy2*dx3)/d;
   if t1 < 0.0 or t1 > 1.0 {
      return false;
   }
   let t2 = (dx1*dy3 - dy1*dx3)/d;
   if t2 < 0.0 or t2 > 1.0 {
    return false;
   }
   return true;
}

proc make_maps() {
   let w = Tile::Wall;
   let o = Tile::Air;
   let s = Tile::Spike;
   let c = Tile::Coin;

   DROP_ROOMS[0] =
   [
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,c,c,o,o,o,o,
      w,o,o,w,w,w,w,o,o,w,
   ];

   DROP_ROOMS[1] =
   [
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,w,o,o,o,o,w,o,o,
      o,o,o,o,c,c,o,o,o,o,
      o,o,o,w,w,w,w,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,w,s,s,s,s,w,o,o,
      o,o,o,w,w,w,w,o,o,o,
      o,o,o,c,w,w,c,o,o,o,
      w,o,o,w,w,w,w,o,o,w,
   ];

    DROP_ROOMS[2] =
    [
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,c,c,o,o,o,o,
      o,o,o,o,w,w,o,o,o,o,
      o,o,o,o,c,c,o,o,o,o,
      o,w,o,o,o,o,o,o,w,o,
      w,w,s,o,o,o,o,s,w,w,
   ];

   DROP_ROOMS[3] =
    [
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,w,w,o,o,w,w,o,o,
      o,w,o,o,c,c,o,o,w,o,
      o,o,o,o,w,w,o,o,o,o,
      w,o,o,o,o,o,o,o,o,w,
      o,w,o,o,o,o,o,o,w,o,
      o,o,o,o,o,o,o,o,o,o,
      w,w,w,o,o,o,o,w,w,w,
      w,w,s,o,o,o,o,s,w,w,
   ];

   DROP_ROOMS[4] =
    [
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,c,c,o,o,o,o,
      o,o,o,o,s,s,o,o,o,o,
      o,o,w,o,w,w,o,w,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,w,o,o,o,o,o,o,w,o,
      w,w,s,o,o,o,o,s,w,w,
   ];


   DROP_ROOMS[5] =
   [
      o,o,o,o,o,o,o,o,o,o,
      w,o,o,o,o,o,o,o,o,w,
      w,w,o,o,o,o,o,o,w,w,
      w,w,o,o,o,o,o,o,w,w,
      w,w,o,o,o,o,o,o,w,w,
      w,w,o,o,o,o,o,o,w,w,
      w,w,o,o,o,o,o,o,w,w,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,c,c,o,o,o,o,
      w,w,w,w,o,o,w,w,w,w,
   ];


   DROP_ROOMS[6] =
   [
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,c,o,o,o,o,c,o,o,
      o,o,w,o,o,o,o,w,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,c,c,o,o,o,o,
      w,o,o,w,w,w,w,o,o,w,
   ];

   HALLWAY_ROOMS[0] =
   [
      w,w,w,w,w,w,w,w,w,w,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      w,w,w,w,w,w,w,w,w,w,
   ];

   HALLWAY_ROOMS[1] =
   [
      w,w,w,w,w,w,w,w,w,w,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,s,o,o,s,o,o,o,s,
      w,w,w,w,w,w,w,w,w,w,
   ];

   HALLWAY_ROOMS[2] =
   [
      w,w,w,w,w,w,w,w,w,w,
      o,o,o,w,w,w,w,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,w,o,o,o,o,w,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,s,s,s,s,s,s,o,o,
      w,w,w,w,w,w,w,w,w,w,
   ];

   HALLWAY_ROOMS[3] =
   [
      w,w,w,w,w,w,w,w,w,w,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,c,o,o,o,o,
      o,c,o,o,o,w,o,o,c,o,
      o,w,o,s,s,s,s,o,w,o,
      o,o,o,w,w,w,w,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      w,w,w,w,w,w,w,w,w,w,
   ];

   HALLWAY_ROOMS[4] =
   [
      w,w,w,w,w,w,w,w,w,w,
      o,w,w,w,w,w,w,w,w,o,
      o,o,w,w,w,w,w,w,o,o,
      o,o,o,w,w,w,w,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,c,o,o,c,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,s,s,o,o,s,s,o,o,
      w,w,w,w,w,w,w,w,w,w,
   ];



   LANDING_ROOMS[0] =
   [
      o,o,o,o,o,o,o,o,o,o,
      o,w,o,o,o,o,o,o,o,o,
      o,o,w,o,o,o,o,o,o,o,
      o,o,o,w,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,w,w,w,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,w,w,w,o,o,w,w,w,o,
      o,o,o,o,o,o,o,o,o,o,
      w,w,w,w,w,w,w,w,w,w,
   ];
   LANDING_ROOMS[1] =
   [
      w,o,o,o,o,o,o,o,o,w,
      o,w,o,o,o,o,o,o,w,o,
      o,w,w,o,o,o,o,w,w,o,
      o,o,o,w,o,o,w,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,c,c,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,s,o,o,o,o,
      w,w,w,w,w,w,w,w,w,w,
   ];

     LANDING_ROOMS[2] =
   [
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,c,o,w,w,w,w,o,c,o,
      o,c,o,o,o,o,o,o,c,o,
      o,w,o,o,o,o,o,o,w,o,
      o,o,o,o,w,w,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,w,o,o,o,o,w,o,o,
      o,o,o,o,s,s,o,o,o,o,
      w,w,w,w,w,w,w,w,w,w,
   ];

   LANDING_ROOMS[3] =
   [
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,c,c,o,o,o,o,
      o,o,o,o,w,w,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      c,o,s,o,o,o,o,s,o,c,
      w,w,w,w,o,o,w,w,w,w,
   ];

     LANDING_ROOMS[4] =
   [
      w,o,o,o,o,o,o,o,o,o,
      o,w,o,o,o,o,o,o,o,o,
      o,o,w,w,o,o,o,o,o,c,
      o,o,o,o,w,o,o,o,c,w,
      o,o,o,o,o,w,o,o,w,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,o,o,o,o,
      o,o,o,o,o,o,s,o,o,o,
      w,w,w,w,w,w,w,w,w,w,
   ];

   BONUS_ROOMS[0] =
   [
      w,w,w,w,w,w,w,w,w,w,
      w,w,w,w,w,w,w,w,w,w,
      w,w,w,w,w,w,w,w,w,w,
      w,w,w,w,w,w,w,w,w,w,
      w,w,w,w,w,w,w,w,w,w,
      w,w,w,w,w,w,w,w,w,w,
      w,w,w,w,w,w,w,w,w,w,
      w,w,w,w,w,w,w,w,w,w,
      w,w,w,w,w,w,w,w,w,w,
      w,w,w,w,w,w,w,w,w,w,
   ];
}

proc reset_game(starting_score: u32) {
   GAME_OVER = false;
   TIME_DEAD = 0;
   JUMP_SPEED = 0.0;
   JUMP_STATE = JumpState::Standing;
   GHOST_IS_PRESENT = false;
   TIME_ALIVE = 0;
   SCORE = starting_score;
   DOOR_CYCLE.current_time_in_animation_seconds = 0.0;

   if RNG == 0 {
      diskr((&RNG) transmute &u8, 8);
      if RNG == 0 {
         RNG = 2;
      }
   }
   diskw((&RNG) transmute &u8, 8);

   carve_path();

   // ensure that the player can't yeet out of the map

   // top row
   let max: usize = 40;
   for i in 0..max {
      TILES[i] = Tile::Wall;
   }

   // bottom row
   for i in 1560..TILES.length {
      TILES[i] = Tile::Wall;
   }

   // left column
   let i: usize = 0;
   loop {
      TILES[i] = Tile::Wall;
      i = i + 40;
      if i >= 1600 {
         break;
      }
   }

   i = 39;
   loop {
      TILES[i] = Tile::Wall;
      i = i + 40;
      if i >= 1600 {
         break;
      }
   }
}

proc carve_path() {
   let starting_cell = rand_range(0, 3);

   let current_cell = starting_cell truncate i32;
   let ending_cell = current_cell;

   let LEFT_EXIT: u8 = 1;
   let RIGHT_EXIT: u8 = 2;
   let UP_EXIT: u8 = 4;
   let DOWN_EXIT: u8 = 8;
   let resulting_types: [u8; 16] =
      [0, 0, 0, 0,
       0, 0, 0, 0,
       0, 0, 0, 0,
       0, 0, 0, 0];
      // 00 01 02 03
      // 04 05 06 07
      // 08 09 10 11
      // 12 13 14 15

   loop {
      let where_to_go = rand_range(1, 5);

      let direction: i32 = 0;
      let next_direction: i32 = 0;
      if where_to_go == 1 or where_to_go == 2 {
         // left
         if (current_cell % 4 == 0) {
            direction = 4;
            next_direction = 1;
         } else {
            direction = -1;
         }
      } else if where_to_go == 3 or where_to_go == 4 {
         // right
         if (current_cell % 4 == 3) {
            direction = 4;
            next_direction = -1;
         } else {
            direction = 1;
         }
      } else if where_to_go == 5 {
         // down
         direction = 4;
      }

      if direction == 4 and current_cell >= 12 {
         // path is done
         ending_cell = current_cell;
         break;
      }



      {
         let cur_cell_usize = current_cell transmute usize;
         let resulting_cell = (current_cell + direction) transmute usize;
         if direction == -1 {
            resulting_types[cur_cell_usize] = resulting_types[cur_cell_usize] | LEFT_EXIT;
            resulting_types[cur_cell_usize] = resulting_types[cur_cell_usize] | RIGHT_EXIT;
            resulting_types[resulting_cell] = resulting_types[resulting_cell] | LEFT_EXIT;
            resulting_types[resulting_cell] = resulting_types[resulting_cell] | RIGHT_EXIT;
         } else if direction == 1 {
            resulting_types[cur_cell_usize] = resulting_types[cur_cell_usize] | LEFT_EXIT;
            resulting_types[cur_cell_usize] = resulting_types[cur_cell_usize] | RIGHT_EXIT;
            resulting_types[resulting_cell] = resulting_types[resulting_cell] | LEFT_EXIT;
            resulting_types[resulting_cell] = resulting_types[resulting_cell] | RIGHT_EXIT;
         } else if direction == 4 {
            resulting_types[cur_cell_usize] = resulting_types[cur_cell_usize] | LEFT_EXIT;
            resulting_types[cur_cell_usize] = resulting_types[cur_cell_usize] | RIGHT_EXIT;
            resulting_types[resulting_cell] = resulting_types[resulting_cell] | LEFT_EXIT;
            resulting_types[resulting_cell] = resulting_types[resulting_cell] | RIGHT_EXIT;
            resulting_types[cur_cell_usize] = resulting_types[cur_cell_usize] | DOWN_EXIT;
            resulting_types[resulting_cell] = resulting_types[resulting_cell] | UP_EXIT;
         }

         current_cell = current_cell + direction;
      }

      if next_direction > 0 {
         direction = next_direction;
         next_direction = 0;

         let cur_cell_usize = current_cell transmute usize;
         let resulting_cell = (current_cell + direction) transmute usize;
         if direction == -1 {
            resulting_types[cur_cell_usize] = resulting_types[cur_cell_usize] | LEFT_EXIT;
            resulting_types[cur_cell_usize] = resulting_types[cur_cell_usize] | RIGHT_EXIT;
            resulting_types[resulting_cell] = resulting_types[resulting_cell] | LEFT_EXIT;
            resulting_types[resulting_cell] = resulting_types[resulting_cell] | RIGHT_EXIT;
         } else if direction == 1 {
            resulting_types[cur_cell_usize] = resulting_types[cur_cell_usize] | LEFT_EXIT;
            resulting_types[cur_cell_usize] = resulting_types[cur_cell_usize] | RIGHT_EXIT;
            resulting_types[resulting_cell] = resulting_types[resulting_cell] | LEFT_EXIT;
            resulting_types[resulting_cell] = resulting_types[resulting_cell] | RIGHT_EXIT;
         } else if direction == 4 {
            resulting_types[cur_cell_usize] = resulting_types[cur_cell_usize] | LEFT_EXIT;
            resulting_types[cur_cell_usize] = resulting_types[cur_cell_usize] | RIGHT_EXIT;
            resulting_types[resulting_cell] = resulting_types[resulting_cell] | LEFT_EXIT;
            resulting_types[resulting_cell] = resulting_types[resulting_cell] | RIGHT_EXIT;
            resulting_types[cur_cell_usize] = resulting_types[cur_cell_usize] | DOWN_EXIT;
            resulting_types[resulting_cell] = resulting_types[resulting_cell] | UP_EXIT;
         }

         current_cell = current_cell + direction;
      }
   }

   for cell_i in 0..resulting_types.length {
      let current_row = cell_i / 4;
      let current_col = cell_i % 4;
      let cell_flags = resulting_types[cell_i];
      let is_hallway = (((cell_flags & LEFT_EXIT) > 0) & ((cell_flags & RIGHT_EXIT) > 0));
      let is_landing = is_hallway & ((cell_flags & UP_EXIT) > 0);
      let is_drop = is_hallway & ((cell_flags & DOWN_EXIT) > 0);

      let map = DROP_ROOMS[0];
      if is_drop {
         let drop_map = rand_range(0, (DROP_ROOMS.length - 1) extend u64);
         map = DROP_ROOMS[drop_map truncate usize];
       } else if is_landing {
         let landing_map = rand_range(0, (LANDING_ROOMS.length - 1) extend u64);
         map = LANDING_ROOMS[landing_map truncate usize];
      } else if is_hallway {
         let hallway_map = rand_range(0, (HALLWAY_ROOMS.length - 1) extend u64);
         map = HALLWAY_ROOMS[hallway_map truncate usize];
      } else {
         map = BONUS_ROOMS[0];
      }

      if cell_i == starting_cell truncate usize {
         // set the player spawn position
         let start_tile: usize = 0;
         loop {
            let test_tile = rand_range(10, map.length extend u64) truncate usize;

            if test_tile % 10 == 0 or test_tile % 10 == 9 {
               continue;
            }

            if map[test_tile] == Tile::Wall and map[test_tile - 10] == Tile::Air {
               start_tile = test_tile - 10;
               break;
            }
         }
         let start_index = ((current_row * 400) + current_col * 10) transmute usize;
         let c_offset = (start_tile / 10) * 40;
         let r_offset = (start_tile % 10);
         let final = start_index + c_offset + r_offset;
         let x = ((final % 40) * 16) truncate f64;
         let y = ((final / 40) * 16) truncate f64;
         PLAYER_POSITION.x = x;
         PLAYER_POSITION.y = y;
      }

      if cell_i == ending_cell transmute usize {
         // stick an exit into the map
         loop {
            let test_tile = rand_range(10, map.length extend u64) truncate usize;

            if test_tile % 10 == 0 or test_tile % 10 == 9 {
               continue;
            }

            if map[test_tile] == Tile::Wall and map[test_tile - 10] == Tile::Air {
               map[test_tile - 10] = Tile::Door;
               break;
            }
         }
      }

      // Hardcode a particular room for testing purposes.
      // map = DROP_ROOMS[0];

      let start_index = ((current_row * 400) + current_col * 10) transmute usize;
      TILES[start_index] = map[0];
      TILES[start_index + 1] = map[1];
      TILES[start_index + 2] = map[2];
      TILES[start_index + 3] = map[3];
      TILES[start_index + 4] = map[4];
      TILES[start_index + 5] = map[5];
      TILES[start_index + 6] = map[6];
      TILES[start_index + 7] = map[7];
      TILES[start_index + 8] = map[8];
      TILES[start_index + 9] = map[9];
      TILES[start_index + 40] = map[10];
      TILES[start_index + 41] = map[11];
      TILES[start_index + 42] = map[12];
      TILES[start_index + 43] = map[13];
      TILES[start_index + 44] = map[14];
      TILES[start_index + 45] = map[15];
      TILES[start_index + 46] = map[16];
      TILES[start_index + 47] = map[17];
      TILES[start_index + 48] = map[18];
      TILES[start_index + 49] = map[19];
      TILES[start_index + 80] = map[20];
      TILES[start_index + 81] = map[21];
      TILES[start_index + 82] = map[22];
      TILES[start_index + 83] = map[23];
      TILES[start_index + 84] = map[24];
      TILES[start_index + 85] = map[25];
      TILES[start_index + 86] = map[26];
      TILES[start_index + 87] = map[27];
      TILES[start_index + 88] = map[28];
      TILES[start_index + 89] = map[29];
      TILES[start_index + 120] = map[30];
      TILES[start_index + 121] = map[31];
      TILES[start_index + 122] = map[32];
      TILES[start_index + 123] = map[33];
      TILES[start_index + 124] = map[34];
      TILES[start_index + 125] = map[35];
      TILES[start_index + 126] = map[36];
      TILES[start_index + 127] = map[37];
      TILES[start_index + 128] = map[38];
      TILES[start_index + 129] = map[39];
      TILES[start_index + 160] = map[40];
      TILES[start_index + 161] = map[41];
      TILES[start_index + 162] = map[42];
      TILES[start_index + 163] = map[43];
      TILES[start_index + 164] = map[44];
      TILES[start_index + 165] = map[45];
      TILES[start_index + 166] = map[46];
      TILES[start_index + 167] = map[47];
      TILES[start_index + 168] = map[48];
      TILES[start_index + 169] = map[49];
      TILES[start_index + 200] = map[50];
      TILES[start_index + 201] = map[51];
      TILES[start_index + 202] = map[52];
      TILES[start_index + 203] = map[53];
      TILES[start_index + 204] = map[54];
      TILES[start_index + 205] = map[55];
      TILES[start_index + 206] = map[56];
      TILES[start_index + 207] = map[57];
      TILES[start_index + 208] = map[58];
      TILES[start_index + 209] = map[59];
      TILES[start_index + 240] = map[60];
      TILES[start_index + 241] = map[61];
      TILES[start_index + 242] = map[62];
      TILES[start_index + 243] = map[63];
      TILES[start_index + 244] = map[64];
      TILES[start_index + 245] = map[65];
      TILES[start_index + 246] = map[66];
      TILES[start_index + 247] = map[67];
      TILES[start_index + 248] = map[68];
      TILES[start_index + 249] = map[69];
      TILES[start_index + 280] = map[70];
      TILES[start_index + 281] = map[71];
      TILES[start_index + 282] = map[72];
      TILES[start_index + 283] = map[73];
      TILES[start_index + 284] = map[74];
      TILES[start_index + 285] = map[75];
      TILES[start_index + 286] = map[76];
      TILES[start_index + 287] = map[77];
      TILES[start_index + 288] = map[78];
      TILES[start_index + 289] = map[79];
      TILES[start_index + 320] = map[80];
      TILES[start_index + 321] = map[81];
      TILES[start_index + 322] = map[82];
      TILES[start_index + 323] = map[83];
      TILES[start_index + 324] = map[84];
      TILES[start_index + 325] = map[85];
      TILES[start_index + 326] = map[86];
      TILES[start_index + 327] = map[87];
      TILES[start_index + 328] = map[88];
      TILES[start_index + 329] = map[89];
      TILES[start_index + 360] = map[90];
      TILES[start_index + 361] = map[91];
      TILES[start_index + 362] = map[92];
      TILES[start_index + 363] = map[93];
      TILES[start_index + 364] = map[94];
      TILES[start_index + 365] = map[95];
      TILES[start_index + 366] = map[96];
      TILES[start_index + 367] = map[97];
      TILES[start_index + 368] = map[98];
      TILES[start_index + 369] = map[99];
   }
}

proc shade(rgb: u32, shade_factor: f64) -> u32 {
   let b = ((rgb & 0x0000FF) truncate f64) / 255.0;
   let g = (((rgb & 0x00FF00) >> 8) truncate f64) / 255.0;
   let r = (((rgb & 0xFF0000) >> 16) truncate f64) / 255.0;

   let new_r = ((r * (1.0 - shade_factor)) * 255.0) truncate u32;
   let new_g = ((g * (1.0 - shade_factor)) * 255.0) truncate u32;
   let new_b = ((b * (1.0 - shade_factor)) * 255.0) truncate u32;

   return (new_r << 16) | (new_b << 8) | new_g;
}

proc start() {
   //         [ black,   grey,    brown,     white  ]
   PALETTE~ = [0x211e20, 0x555568,0xa0a08b,0xe9efec];
   DRAW_COLORS~ = 0x2340;
   make_maps();
   reset_game(0);
}

proc sim(dt: f64) {
   if GAME_OVER | DOING_DOOR {
      return;
   }

   {
      if (!GHOST_IS_PRESENT) {
         maybe_spawn_ghost();
      }
      move_ghost(dt);
   }

   // Handle input
   let jump_pressed = (GAMEPADS~[0] & BUTTON_1) > 0;
   if jump_pressed and JUMP_STATE == JumpState::Standing {
      JUMP_STATE = JumpState::Jumping;
      JUMP_SPEED = 9.0;
      tone(300 | (800 << 16), 6, 50, TONE_MODE1);
   } else if (false) and TIME_DEAD >= 5 {
      reset_game(0);
      return;
   }

   let left_pressed = (GAMEPADS~[0] & BUTTON_LEFT) > 0;
   let right_pressed = (GAMEPADS~[0] & BUTTON_RIGHT) > 0;

   let go_left = left_pressed & !right_pressed;
   let go_right = right_pressed & !left_pressed;

   let offset: f64 = 0.0;
   if go_left {
      PLAYER_POSITION.x = PLAYER_POSITION.x - (2.0 * dt);
      offset = TILE_WIDTH;
      PLAYER_FACING_LEFT = true;
      PLAYER_MOVED_ON_LAST_FRAME = true;
   } else if go_right {
      PLAYER_POSITION.x = PLAYER_POSITION.x + (2.0 * dt);
      offset = TILE_WIDTH*-1.0;
      PLAYER_FACING_LEFT = false;
      PLAYER_MOVED_ON_LAST_FRAME = true;
   }
   else {
      PLAYER_MOVED_ON_LAST_FRAME = false;
   }

   for i in 0..TILES.length {
      if TILES[i] == Tile::Air {
         continue;
      }

      let x = ((i % 40) * 16) truncate f64;
      let y = ((i / 40) * 16) truncate f64;
      if rectangles_collide(PLAYER_POSITION.x, PLAYER_POSITION.y, PLAYER_WIDTH, PLAYER_HEIGHT, x, y, TILE_WIDTH, TILE_HEIGHT) {
         if TILES[i] == Tile::Coin {
            handle_coin_collision(i);
         } else if TILES[i] == Tile::Door {
            PLAYER_POSITION.x = x + offset;
            handle_door_collision();
         } else if TILES[i] == Tile::Spike {
                  let midpoint = x + (TILE_WIDTH / 2.0);
                  // left edge of player
                  let fipt = segment_v_segment(PLAYER_POSITION.x, PLAYER_POSITION.y, PLAYER_POSITION.x, PLAYER_POSITION.y + PLAYER_HEIGHT, midpoint, y, x, y + TILE_HEIGHT);
                  let spt = segment_v_segment(PLAYER_POSITION.x, PLAYER_POSITION.y, PLAYER_POSITION.x, PLAYER_POSITION.y + PLAYER_HEIGHT, midpoint, y, x + TILE_WIDTH, y + TILE_HEIGHT);
                  // right edge of player
                  let tpt = segment_v_segment(PLAYER_POSITION.x + PLAYER_WIDTH, PLAYER_POSITION.y, PLAYER_POSITION.x + PLAYER_WIDTH, PLAYER_POSITION.y + PLAYER_HEIGHT, midpoint, y, x, y + TILE_HEIGHT);
                  let fopt = segment_v_segment(PLAYER_POSITION.x + PLAYER_WIDTH, PLAYER_POSITION.y, PLAYER_POSITION.x + PLAYER_WIDTH, PLAYER_POSITION.y + PLAYER_HEIGHT, midpoint, y, x + TILE_WIDTH, y + TILE_HEIGHT);
                  // bottom of player
                  let ffpt = segment_v_segment(PLAYER_POSITION.x, PLAYER_POSITION.y + PLAYER_HEIGHT, PLAYER_POSITION.x + PLAYER_WIDTH, PLAYER_POSITION.y + PLAYER_HEIGHT, midpoint, y, x, y + TILE_HEIGHT);
                  let fifpt = segment_v_segment(PLAYER_POSITION.x, PLAYER_POSITION.y + PLAYER_HEIGHT, PLAYER_POSITION.x + PLAYER_WIDTH, PLAYER_POSITION.y + PLAYER_HEIGHT, midpoint, y, x + TILE_WIDTH, y + TILE_HEIGHT);
                  let touched_spike = fipt | spt | tpt | fopt | fipt | ffpt | fifpt;
                  if touched_spike {
                     PLAYER_POSITION.x = x + offset;
                  }
         } else {
            PLAYER_POSITION.x = x + offset;
         }
      }
   }
   if (GHOST_IS_PRESENT) {
      // Check if colliding with ghost
      if rectangles_collide(PLAYER_POSITION.x, PLAYER_POSITION.y, PLAYER_WIDTH, PLAYER_HEIGHT, GHOST_POSITION.x, GHOST_POSITION.y, GHOST_WIDTH truncate f64, GHOST_HEIGHT truncate f64) {
            maybe_play_game_over_noise();
            GAME_OVER = true;
            return;
      }
   }

   // Do jumping
   {
      if JUMP_STATE == JumpState::Jumping {
         JUMP_SPEED = JUMP_SPEED - (0.7 * dt);
         PLAYER_POSITION.y = PLAYER_POSITION.y - (JUMP_SPEED * dt);
         if (JUMP_SPEED <= 0.0) {
            JUMP_SPEED = 0.0;
            JUMP_STATE = JumpState::Falling;
         }

         for i in 0..TILES.length {
            if TILES[i] == Tile::Air {
               continue;
            }

            let x = ((i % 40) * 16) truncate f64;
            let y = ((i / 40) * 16) truncate f64;
            if rectangles_collide(PLAYER_POSITION.x, PLAYER_POSITION.y, 16.0, 16.0, x, y, 16.0, 16.0) {
               if TILES[i] == Tile::Coin {
                  handle_coin_collision(i);
               } else if TILES[i] == Tile::Spike {
                  // h,,,
               } else {
                  PLAYER_POSITION.y = y + 16.0;
                  JUMP_SPEED = 0.0;
                  JUMP_STATE = JumpState::Falling;
               }
            }
         }
      } else if JUMP_STATE == JumpState::Falling {
         JUMP_SPEED = JUMP_SPEED + (0.2 * dt);
         if (JUMP_SPEED > TERMINAL_VELOCITY) {
            JUMP_SPEED = TERMINAL_VELOCITY;
         }

         PLAYER_POSITION.y = PLAYER_POSITION.y + (JUMP_SPEED * dt);

         let touched_door: bool = false;
         let touched_spike: bool = false;
         for i in 0..TILES.length {
            if TILES[i] == Tile::Air{
               continue;
            }
            let x = ((i % 40) * 16) truncate f64;
            let y = ((i / 40) * 16) truncate f64;
            if rectangles_collide(PLAYER_POSITION.x, PLAYER_POSITION.y, PLAYER_WIDTH, PLAYER_HEIGHT, x, y, TILE_WIDTH, TILE_HEIGHT) {
               if TILES[i] == Tile::Coin {
                  handle_coin_collision(i);
               } else if TILES[i] == Tile::Spike {
                  let midpoint = x + (TILE_WIDTH / 2.0);
                  // left edge of player
                  let fipt = segment_v_segment(PLAYER_POSITION.x, PLAYER_POSITION.y, PLAYER_POSITION.x, PLAYER_POSITION.y + PLAYER_HEIGHT, midpoint, y, x, y + TILE_HEIGHT);
                  let spt = segment_v_segment(PLAYER_POSITION.x, PLAYER_POSITION.y, PLAYER_POSITION.x, PLAYER_POSITION.y + PLAYER_HEIGHT, midpoint, y, x + TILE_WIDTH, y + TILE_HEIGHT);
                  // right edge of player
                  let tpt = segment_v_segment(PLAYER_POSITION.x + PLAYER_WIDTH, PLAYER_POSITION.y, PLAYER_POSITION.x + PLAYER_WIDTH, PLAYER_POSITION.y + PLAYER_HEIGHT, midpoint, y, x, y + TILE_HEIGHT);
                  let fopt = segment_v_segment(PLAYER_POSITION.x + PLAYER_WIDTH, PLAYER_POSITION.y, PLAYER_POSITION.x + PLAYER_WIDTH, PLAYER_POSITION.y + PLAYER_HEIGHT, midpoint, y, x + TILE_WIDTH, y + TILE_HEIGHT);
                  // bottom of player
                  let ffpt = segment_v_segment(PLAYER_POSITION.x, PLAYER_POSITION.y + PLAYER_HEIGHT, PLAYER_POSITION.x + PLAYER_WIDTH, PLAYER_POSITION.y + PLAYER_HEIGHT, midpoint, y, x, y + TILE_HEIGHT);
                  let fifpt = segment_v_segment(PLAYER_POSITION.x, PLAYER_POSITION.y + PLAYER_HEIGHT, PLAYER_POSITION.x + PLAYER_WIDTH, PLAYER_POSITION.y + PLAYER_HEIGHT, midpoint, y, x + TILE_WIDTH, y + TILE_HEIGHT);
                  touched_spike = fipt | spt | tpt | fopt | fipt | ffpt | fifpt;
               } else if TILES[i] == Tile::Door {
                  touched_door = true;
                  PLAYER_POSITION.y = y - TILE_HEIGHT;
                  JUMP_STATE = JumpState::Standing;
                  break;
               } else {
                  PLAYER_POSITION.y = y - TILE_HEIGHT;
                  JUMP_STATE = JumpState::Standing;
               }
            }
         }
         if touched_door {
            handle_door_collision();
         } else if touched_spike {
            // hit a spike, wasn't touching door. end early.
            maybe_play_game_over_noise();
            GAME_OVER = true;
            return;
         }
      } else if JUMP_STATE == JumpState::Standing {
         let ontop = false;
         for i in 0..TILES.length {
            if TILES[i] == Tile::Air or TILES[i] == Tile::Coin or TILES[i] == Tile::Spike or TILES[i] == Tile::Door {
               continue;
            }

            let x = ((i % 40) * 16) truncate f64;
            let y = ((i / 40) * 16) truncate f64;
            if rectangles_collide(PLAYER_POSITION.x, PLAYER_POSITION.y + 0.1, PLAYER_WIDTH, PLAYER_HEIGHT, x, y, TILE_WIDTH, TILE_HEIGHT) {
               ontop = true;
               break;
            }
         }
         if !ontop {
            JUMP_SPEED = 0.0;
            JUMP_STATE = JumpState::Falling;
         }
      }
   }
}

proc handle_coin_collision(current_tile_index: usize) {
   tone(500 | (1000 << 16), 3, 50, TONE_MODE1);
   SCORE = SCORE + 1;
   TILES[current_tile_index] = Tile::Air;
}

proc handle_door_collision() {
   DOING_DOOR = true;
   tone(90 | (160 << 16), (100 << 24) | (86 << 16) | 10 | (166 << 8), 3, 3 | (0 << 2));
   SCORE = SCORE + 5;
}

proc update() {
   update_timers();

   let gamepad = GAMEPADS~[0];
   let pressed_this_frame = gamepad & (gamepad ^ LAST_GAMEPAD);
   LAST_GAMEPAD = gamepad;

   let reset_pressed = (pressed_this_frame & BUTTON_2) > 0;
   if reset_pressed {
      reset_game(0);
   }

   if DOING_DOOR {
      PALETTE~[0] = shade(PALETTE~[0], 0.01);
      PALETTE~[1] = shade(PALETTE~[1], 0.01);
      PALETTE~[2] = shade(PALETTE~[2], 0.01);
      PALETTE~[3] = shade(PALETTE~[3], 0.01);

      if TIME_DOING_DOOR > 150 {
         DOING_DOOR = false;
         TIME_DOING_DOOR = 0;
         PALETTE~ = [0x211e20, 0x555568,0xa0a08b,0xe9efec];
         reset_game(SCORE);
         return;
      }
   } else {
      sim(0.1);
      sim(0.1);
      sim(0.1);
      sim(0.1);
      sim(0.1);
      sim(0.1);
      sim(0.1);
      sim(0.1);
      sim(0.1);
      sim(0.1);
   }

   // Draw world
   {

      // Always keep camera centered
      let center_of_player = PLAYER_POSITION;
      center_of_player.x = center_of_player.x + 5.0;
      center_of_player.y = center_of_player.y + 8.0;
      let clens: usize = 16;
      let closest_cam: usize = 0;
      let min_dist: f64 = dist(center_of_player, CAMERAS[0]);
      for x in 1..clens {
         let dist = dist(center_of_player, CAMERAS[x]);
         if dist < min_dist {
            min_dist = dist;
            closest_cam = x;
         }
      }

      let camera_position = CAMERAS[closest_cam];
      camera_position.x = PLAYER_POSITION.x + 5.0;
      camera_position.y = PLAYER_POSITION.y + 8.0;

      let camera_offset_x: f64 = (camera_position.x) - 80.0;
      let camera_offset_y: f64 = (camera_position.y) - 80.0;

      // Draw player
      draw_player((PLAYER_POSITION.x - camera_offset_x) truncate i32, (PLAYER_POSITION.y - camera_offset_y) truncate i32, JUMP_STATE);

      if (GHOST_IS_PRESENT) {
         draw_ghost(camera_offset_x, camera_offset_y);
      }

      for i in 0..TILES.length {
         let x = ((i % 40) * 16) truncate f64;
         let y = ((i / 40) * 16) truncate f64;
         if TILES[i] == Tile::Air {
            continue;
         } else if TILES[i] == Tile::Wall {
            blit_sub(&BLOCKS[0], (x - camera_offset_x) truncate i32, (y - camera_offset_y) truncate i32, 16, 16, 0, 0, BLOCKS_WIDTH, BLOCKS_FLAGS);
         } else if TILES[i] == Tile::Spike {
            blit_sub(&SPIKES[0], (x - camera_offset_x) truncate i32, (y - camera_offset_y) truncate i32, 16, 16, 0, 0, SPIKES_WIDTH, SPIKES_FLAGS);
         } else if TILES[i] == Tile::Door{
            if DOING_DOOR {
               let door_spritesheet_x = advance_animation_and_return_x(&DOOR_CYCLE, (1.0/60.0));
               blit_sub(&DOOR[0], (x - camera_offset_x) truncate i32, (y - camera_offset_y) truncate i32, 16, 16, door_spritesheet_x, 0, DOOR_WIDTH, DOOR_FLAGS);
            } else {
               blit_sub(&DOOR[0], (x - camera_offset_x) truncate i32, (y - camera_offset_y) truncate i32, 16, 16, 0, 0, DOOR_WIDTH, DOOR_FLAGS);
            }
         } else if TILES[i] == Tile::Coin {
            let coin_spritesheet_x = advance_animation_and_return_x(&COIN_CYCLE, (1.0/60.0));
            blit_sub(&COIN[0], (x - camera_offset_x) truncate i32, (y - camera_offset_y) truncate i32, 16, 16, coin_spritesheet_x, 0, COIN_WIDTH, COIN_FLAGS);
         }
      }
      FRAME_COUNT = FRAME_COUNT+1;
   }

   //trace(int_to_string(PLAYER_POSITION.y truncate u32, &SCORE_BUF));

   // Draw UI
   {
      let tmp: u16 = DRAW_COLORS~;
      // use black (color 1) as text color, and white (color 4) as the background.
      DRAW_COLORS~ = 0x2341;
      text("SCORE: ", 2, 2);
      text(int_to_string(SCORE, &SCORE_BUF), 47, 2);
      DRAW_COLORS~ = tmp;
      if GAME_OVER {
         draw_game_over_text();
      }
   }
}

// Player animations, and related stuff.
enum CurrentPlayerAnimationCycle {
   // TODO: add "player hurt" cycle, "player death" cycle etc.
   Jumping,
   Standing,
   Falling,
}

static PREVIOUS_JUMP_STATE: JumpState = JumpState::Standing;

static CURRENT_PLAYER_ANIMATION_CYCLE: CurrentPlayerAnimationCycle = CurrentPlayerAnimationCycle::Standing;

struct AnimationCycle {
   current_time_in_animation_seconds: f64,
   animation_length_seconds: f64, // 4.0 = animation loops over 4 seconds, etc.
   animation_sprites: i32,
   starting_animation_x: i32,
   offset_between_sprites: i32,
   repeat_cycle: bool,
}

static RUNNING_CYCLE : AnimationCycle = AnimationCycle {
   current_time_in_animation_seconds: 0.0,
   animation_length_seconds: 1.0,
   animation_sprites: 8,
   starting_animation_x: 160,
   offset_between_sprites: 20,
   repeat_cycle: true,
};

static IDLE_CYCLE : AnimationCycle = AnimationCycle {
   current_time_in_animation_seconds: 0.0,
   animation_length_seconds: 1.0,
   animation_sprites: 8,
   starting_animation_x: 0,
   offset_between_sprites: 20,
   repeat_cycle: true,
};

const JUMP_SPRITE_X: i32 = 320;
const FALLING_SPRITE_X: i32 = 340;

// Frames since the game has begun. Game runs at 60 fps.
static FRAME_COUNT:u32 = 0;

proc advance_animation_and_return_x(anim_cycle: &AnimationCycle, seconds_to_advance: f64) -> i32 {
   anim_cycle~.current_time_in_animation_seconds = anim_cycle~.current_time_in_animation_seconds + seconds_to_advance;

   if (anim_cycle~.current_time_in_animation_seconds >= anim_cycle~.animation_length_seconds) {
       if anim_cycle~.repeat_cycle {
         anim_cycle~.current_time_in_animation_seconds = 0.0;
       } else {
         anim_cycle~.current_time_in_animation_seconds = anim_cycle~.animation_length_seconds;
       }
   }
   // Calculate the location of the correct sprite.
   let ratio: f64 = 0.0;
   if anim_cycle~.current_time_in_animation_seconds > 0.0 {
      ratio =  (anim_cycle~.current_time_in_animation_seconds/anim_cycle~.animation_length_seconds);
   }

   let sprite_index = ((ratio * (anim_cycle~.animation_sprites -1) truncate f64) truncate i32);
   let x = anim_cycle~.starting_animation_x + anim_cycle~.offset_between_sprites*sprite_index;
   return x;
}

// Returns the x value in the PLAYER_SPRITESHEET of the next sprite for the player.
//
// Note this advances the current animation to the next frame and therefore should only be called once per draw loop.
proc get_next_player_sprite_x(current_jump_state: JumpState, previous_jump_state: JumpState) -> i32 {
   // TODO worry about previous jump state.
   if current_jump_state == JumpState::Jumping {
      return JUMP_SPRITE_X;
   }
   if (current_jump_state == JumpState::Falling) {
      return FALLING_SPRITE_X;
   }
   if (PLAYER_MOVED_ON_LAST_FRAME) {
      return advance_animation_and_return_x(&RUNNING_CYCLE, (1.0/60.0));
   }
   return advance_animation_and_return_x(&IDLE_CYCLE, (1.0/60.0));
}

proc draw_player(player_x: i32, player_y: i32, jump_state: JumpState) {
   let tmp: u16 = DRAW_COLORS~;
   DRAW_COLORS~ = 0x2340;

   let current_sprite_y: i32 = 0;
   let current_sprite_x: i32 = get_next_player_sprite_x(jump_state, PREVIOUS_JUMP_STATE);
   blit_sub(&PLAYER_SPRITESHEET[0], player_x -1 , player_y - 2, 20, 18, current_sprite_x, current_sprite_y, PLAYER_SPRITESHEET_WIDTH, PLAYER_SPREADSHEET_FLAGS | (PLAYER_FACING_LEFT extend u32 << 1));
   // one array for jumping (8 sprites), one array for running (2 sprites), one array for idle (8 sprites).
   DRAW_COLORS~ = tmp;
}


const GHOST_SPAWN_TIME: u64 = 60*25; // Number of frames after which the ghost should spawn.
static GHOST_IS_PRESENT: bool;
static GHOST_FACING_LEFT: bool;
static GHOST_POSITION: Position;
const GHOST_HEIGHT: u32 = 30;
const GHOST_WIDTH: u32 = 30;
const GHOST_SPEED: u64 = 1;
const DEFAULT_VOLUME: u32 = 50;


proc update_timers() {
   if GAME_OVER {
      TIME_DEAD = TIME_DEAD + 1;
   } else {
      TIME_ALIVE = TIME_ALIVE + 1;
      if DOING_DOOR {
         TIME_DOING_DOOR = TIME_DOING_DOOR + 1;
      }
   }
}

proc maybe_spawn_ghost() {
   if (TIME_ALIVE > GHOST_SPAWN_TIME) {
      GHOST_IS_PRESENT = true;
      // TODO: spawn in opposite corner of player, instead of top left.
      GHOST_POSITION.x = 0.0;
      GHOST_POSITION.y = 0.0;

      let starting_freq: u32 = 250;
      let ending_freq: u32 = 350;
      let decay: u32 = 42;
      let release: u32 = 106;
      tone(starting_freq | (ending_freq << 16), (0 | (release << 8) | (decay << 16)), DEFAULT_VOLUME, TONE_PULSE2 | TONE_MODE1);
   }
}

// Caller should check if GHOST_IS_PRESENT before moving.
proc move_ghost(dt: f64) {
   // if player x > ghost x, ghost x++
   // if player x < ghost x, ghost x--
   if (PLAYER_POSITION.x > GHOST_POSITION.x) {
      GHOST_POSITION.x = GHOST_POSITION.x + (1.0 * dt);
      GHOST_FACING_LEFT = false;
   }
   else {
      GHOST_POSITION.x = GHOST_POSITION.x - (1.0 * dt);
      GHOST_FACING_LEFT = true;
   }
   if (PLAYER_POSITION.y >= GHOST_POSITION.y) {
      GHOST_POSITION.y = GHOST_POSITION.y + (1.0 * dt);
   }
   else {
      GHOST_POSITION.y = GHOST_POSITION.y - (1.0 * dt);
   }
}

// TODO: add some other color to the ghost to make it stand out.
proc draw_ghost(camera_offset_x: f64, camera_offset_y: f64) {
   // Draw ghost body.
   let ghost_draw_x = (GHOST_POSITION.x - camera_offset_x) truncate i32;
   let ghost_draw_y = (GHOST_POSITION.y - camera_offset_y) truncate i32;
   rect(ghost_draw_x, ghost_draw_y, GHOST_WIDTH, GHOST_HEIGHT);
   // Draw ghost eyes.

   let ghost_left_eye_x = ghost_draw_x;
   let ghost_right_eye_x = ghost_draw_x;
   if GHOST_FACING_LEFT {
      ghost_left_eye_x =  ghost_left_eye_x + 5;
      ghost_right_eye_x =  ghost_right_eye_x + 10;
   } else {
      ghost_left_eye_x =  ghost_left_eye_x + 15;
      ghost_right_eye_x =  ghost_right_eye_x + 20;
   }
   rect(ghost_right_eye_x, ghost_draw_y + 6, 4, 5);
   rect(ghost_left_eye_x, ghost_draw_y + 4, 4, 5);
   // draw mouth
   rect(ghost_left_eye_x, ghost_draw_y + 12, 12, 10);

}

proc draw_game_over_text() {
   let tmp: u16 = DRAW_COLORS~;
   // use black (color 1) as text color, and white (color 4) as the background.
   DRAW_COLORS~ = 0x2341;
   text("DEATH", 40, 50);
   DRAW_COLORS~ = tmp;
}

proc maybe_play_game_over_noise() {
   if !GAME_OVER {
     let starting_freq: u32 = 590;
     let ending_freq: u32 = 110;
     tone(starting_freq| (ending_freq << 16), 60, DEFAULT_VOLUME, TONE_PULSE1 | TONE_MODE3);
   }
}


// Player spritesheet
const PLAYER_SPRITESHEET_WIDTH: u32 = 380;
const PLAYER_SPRITESHEET_HEIGHT: u32 = 18;
const PLAYER_SPREADSHEET_FLAGS: u32 = 1; // BLIT_2BPP
static PLAYER_SPRITESHEET: [u8; 1710] = [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xff,0xf5,0x00,0x00,0x55,0xaa,0xa5,0x00,0x05,0x50,0x00,0x00,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xff,0xf5,0x00,0x00,0x55,0xaa,0xa5,0x00,0x05,0x50,0x00,0x00,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x5a,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x5a,0xaa,0xa5,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x05,0xaa,0xaa,0xaa,0x50,0x5a,0xa5,0x55,0x55,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x5a,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x5a,0xaa,0xa5,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x05,0xaa,0xaa,0xaa,0x50,0x5a,0xa5,0x55,0x55,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x5a,0xaa,0xa5,0x00,0x00,0x5a,0xfa,0xf5,0x00,0x00,0x5a,0xff,0xf5,0x50,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xfa,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x00,0x5f,0xff,0xf5,0x00,0x05,0xaa,0xff,0xfa,0x50,0x5a,0xa5,0xaa,0xa5,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x05,0xaa,0xa5,0x00,0x00,0x5a,0xaa,0xa5,0x00,0x00,0x5a,0xfa,0xf5,0x00,0x00,0x5a,0xff,0xf5,0x50,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xfa,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x00,0x5f,0xff,0xf5,0x00,0x05,0xaa,0xff,0xfa,0x50,0x5a,0xa5,0xaa,0xa5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x00,0x5a,0xfa,0xf5,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xfa,0xf5,0x00,0x05,0x5f,0xfa,0xf5,0x50,0x05,0x5f,0xfa,0xf5,0xa5,0x05,0x5f,0xfa,0xf5,0x50,0x00,0x5f,0xfa,0xf5,0x50,0x05,0xaa,0xaa,0xfa,0x50,0x00,0x5a,0xaf,0xf5,0x00,0x05,0xaa,0xaf,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x00,0x5f,0xff,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x05,0x5a,0xff,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x00,0x5a,0xfa,0xf5,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xff,0xf5,0x00,0x00,0x5a,0xfa,0xf5,0x00,0x05,0x5f,0xfa,0xf5,0x50,0x05,0x5f,0xfa,0xf5,0xa5,0x05,0x5f,0xfa,0xf5,0x50,0x00,0x5f,0xfa,0xf5,0x50,0x05,0xaa,0xaa,0xfa,0x50,0x00,0x5a,0xaf,0xf5,0x00,0x05,0xaa,0xaf,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x00,0x5f,0xff,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x05,0x5a,0xff,0xf5,0x00,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x00,0x5f,0xff,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x05,0xaa,0xfa,0xfa,0x50,0x05,0xaa,0xfa,0xfa,0x50,0x05,0xaa,0xfa,0xfa,0x50,0x5a,0xaa,0xff,0xfa,0xa5,0x5a,0xaf,0xff,0xfa,0xa5,0x5a,0xaa,0xff,0xfa,0xa5,0x05,0xaa,0xff,0xfa,0xa5,0x05,0xaa,0xaf,0xfa,0x50,0x00,0x5a,0xaf,0xf5,0x00,0x05,0xaa,0xaf,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x00,0x5f,0xff,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x00,0x5f,0xff,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x05,0xaa,0xfa,0xfa,0x50,0x05,0xaa,0xfa,0xfa,0x50,0x05,0xaa,0xfa,0xfa,0x50,0x5a,0xaa,0xff,0xfa,0xa5,0x5a,0xaf,0xff,0xfa,0xa5,0x5a,0xaa,0xff,0xfa,0xa5,0x05,0xaa,0xff,0xfa,0xa5,0x05,0xaa,0xaf,0xfa,0x50,0x00,0x5a,0xaf,0xf5,0x00,0x05,0xaa,0xaf,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x00,0x5f,0xff,0xf5,0x00,0x00,0x5f,0xfa,0xf5,0x00,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x5a,0xaa,0xff,0xfa,0xa5,0x5a,0xaf,0xff,0xfa,0xa5,0x5a,0xaa,0xff,0xfa,0xa5,0x05,0xaa,0xff,0xfa,0xa5,0x00,0x5f,0xff,0xf5,0x00,0x05,0xff,0xff,0xff,0x50,0x00,0x5f,0xff,0xf5,0x00,0x00,0x5f,0xff,0xf5,0x00,0x05,0xaa,0xff,0xfa,0x50,0x00,0x5f,0xff,0xff,0x50,0x00,0x5f,0xff,0xf5,0x00,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x5a,0xaa,0xff,0xfa,0xa5,0x5a,0xaf,0xff,0xfa,0xa5,0x5a,0xaa,0xff,0xfa,0xa5,0x05,0xaa,0xff,0xfa,0xa5,0x00,0x5f,0xff,0xf5,0x00,0x05,0xff,0xff,0xff,0x50,0x00,0x5f,0xff,0xf5,0x00,0x00,0x5f,0xff,0xf5,0x00,0x05,0xaa,0xff,0xfa,0x50,0x00,0x5f,0xff,0xff,0x50,0x00,0x5f,0xff,0xf5,0x00,0x00,0x5f,0xff,0xf5,0x00,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x00,0x5f,0xff,0xf5,0x00,0x00,0x5f,0xff,0xf5,0x00,0x05,0x5f,0xff,0xf5,0x50,0x05,0x5f,0xff,0xf5,0x50,0x05,0x5f,0xff,0xf5,0x50,0x00,0x5f,0xff,0xf5,0x50,0x05,0xf5,0x55,0x5f,0x50,0x05,0x55,0x55,0x55,0x50,0x05,0xf5,0x55,0x5f,0x50,0x05,0xf5,0x55,0x5f,0x50,0x00,0x5f,0x55,0xf5,0x00,0x00,0x55,0xf5,0x55,0x00,0x05,0xff,0xff,0x50,0x00,0x00,0x5f,0xff,0xf5,0x00,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x05,0xaa,0xff,0xfa,0x50,0x00,0x5f,0xff,0xf5,0x00,0x00,0x5f,0xff,0xf5,0x00,0x05,0x5f,0xff,0xf5,0x50,0x05,0x5f,0xff,0xf5,0x50,0x05,0x5f,0xff,0xf5,0x50,0x00,0x5f,0xff,0xf5,0x50,0x05,0xf5,0x55,0x5f,0x50,0x05,0x55,0x55,0x55,0x50,0x05,0xf5,0x55,0x5f,0x50,0x05,0xf5,0x55,0x5f,0x50,0x00,0x5f,0x55,0xf5,0x00,0x00,0x55,0xf5,0x55,0x00,0x05,0xff,0xff,0x50,0x00,0x00,0x5f,0x55,0xf5,0x00,0x00,0x5f,0x55,0xf5,0x00,0x00,0x5f,0x55,0xf5,0x00,0x00,0x5f,0x55,0xf5,0x00,0x00,0x5f,0x55,0xf5,0x00,0x00,0x5f,0x55,0xf5,0x00,0x00,0x5f,0x55,0xf5,0x00,0x00,0x5f,0x55,0xf5,0x00,0x00,0x05,0xff,0x50,0x00,0x00,0x5f,0x55,0xf5,0x00,0x00,0x05,0xff,0x50,0x00,0x00,0x5f,0x55,0xf5,0x00,0x05,0x50,0x00,0x05,0x50,0x00,0x00,0x00,0x00,0x00,0x05,0x50,0x00,0x05,0x50,0x05,0x50,0x00,0x05,0x50,0x00,0x55,0x00,0x55,0x00,0x00,0x00,0x55,0x00,0x00,0x00,0x5f,0x55,0x00,0x00,0x00,0x5f,0x55,0xf5,0x00,0x00,0x5f,0x55,0xf5,0x00,0x00,0x5f,0x55,0xf5,0x00,0x00,0x5f,0x55,0xf5,0x00,0x00,0x5f,0x55,0xf5,0x00,0x00,0x5f,0x55,0xf5,0x00,0x00,0x5f,0x55,0xf5,0x00,0x00,0x5f,0x55,0xf5,0x00,0x00,0x05,0xff,0x50,0x00,0x00,0x5f,0x55,0xf5,0x00,0x00,0x05,0xff,0x50,0x00,0x00,0x5f,0x55,0xf5,0x00,0x05,0x50,0x00,0x05,0x50,0x00,0x00,0x00,0x00,0x00,0x05,0x50,0x00,0x05,0x50,0x05,0x50,0x00,0x05,0x50,0x00,0x55,0x00,0x55,0x00,0x00,0x00,0x55,0x00,0x00,0x00,0x5f,0x55,0x00,0x00];

// spikes
const SPIKES_WIDTH: u32 = 32;
const SPIKES_HEIGHT: u32 = 16;
const SPIKES_FLAGS: u32 = 1; // BLIT_2BPP
static SPIKES: [u8; 128] = [0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0xa5,0x00,0x00,0x00,0x50,0x00,0x00,0x05,0xa5,0x00,0x00,0x00,0x50,0x00,0x00,0x5a,0xa5,0x00,0x00,0x05,0xa5,0x00,0x00,0x5a,0xa5,0x00,0x00,0x05,0xa5,0x00,0x00,0x5a,0xa5,0x00,0x00,0x5a,0xa5,0x00,0x00,0x5a,0xa5,0x00,0x00,0x5a,0xa5,0x00,0x05,0xff,0xaa,0x50,0x00,0x5a,0xff,0x50,0x05,0xff,0xaa,0x50,0x00,0x5a,0xff,0x50,0x05,0xff,0xfa,0x50,0x05,0xaa,0xff,0x50,0x05,0xff,0xfa,0x50,0x05,0xaa,0xff,0x50,0x5f,0xff,0xff,0xf5,0x5a,0xff,0xff,0xf5,0x5f,0xff,0xff,0xf5,0x5a,0xff,0xff,0xf5,0x5f,0xff,0xff,0xf5,0x5f,0xff,0xff,0xf5,0x5f,0xff,0xff,0xf5,0x5f,0xff,0xff,0xf5];

// blocks
const BLOCKS_WIDTH: u32 = 112;
const BLOCKS_HEIGHT: u32 = 94;
const BLOCKS_FLAGS: u32 = 1; // BLIT_2BPP
static BLOCKS: [u8; 2632] = [0x05,0x55,0x55,0x55,0x05,0x55,0x55,0x55,0x05,0x55,0x55,0x50,0x00,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0x00,0x05,0x55,0x55,0x50,0x05,0x55,0x55,0x55,0x05,0x55,0x55,0x55,0x05,0x55,0x55,0x50,0x00,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0x00,0x05,0x55,0x55,0x50,0x55,0x55,0x55,0xff,0x55,0x55,0x55,0x55,0xff,0x55,0x55,0x55,0x0a,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xff,0xaa,0xaa,0xa0,0x5a,0xaa,0xaa,0xa5,0x55,0x55,0x55,0xff,0x55,0x55,0x55,0x55,0xff,0x55,0x55,0x55,0x0a,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xff,0xaa,0xaa,0xa0,0x5a,0xaa,0xaa,0xa5,0x55,0x50,0x0f,0xff,0x55,0x55,0x55,0x55,0xff,0xf0,0x05,0x55,0xaa,0xaf,0xff,0xff,0xff,0xff,0xfa,0xaa,0xff,0xff,0xfa,0xaa,0x5a,0xff,0xff,0xa5,0x55,0x50,0x0f,0xff,0x55,0x55,0x55,0x55,0xff,0xf0,0x05,0x55,0xaa,0xaf,0xff,0xff,0xff,0xff,0xfa,0xaa,0xff,0xff,0xfa,0xaa,0x5a,0xff,0xff,0xa5,0x55,0x50,0x0f,0xfa,0xff,0xf0,0x05,0x50,0xaf,0xf0,0x05,0x55,0xaa,0xff,0x00,0x55,0xff,0xf0,0x0f,0xff,0xff,0x00,0xff,0xaa,0x5a,0xf0,0x0f,0xaf,0x55,0x50,0x0f,0xfa,0xff,0xf0,0x05,0x50,0xaf,0xf0,0x05,0x55,0xaa,0xff,0x00,0x55,0xff,0xf0,0x0f,0xff,0xff,0x00,0xff,0xaa,0x5a,0xf0,0x0f,0xaf,0x55,0xff,0xff,0xaa,0xaf,0xf0,0x05,0x50,0xaa,0xaf,0xf5,0x55,0xaa,0xff,0x00,0x55,0xf5,0x50,0x0f,0xf0,0x55,0x00,0xff,0xaa,0x5a,0xf0,0x0f,0xaf,0x55,0xff,0xff,0xaa,0xaf,0xf0,0x05,0x50,0xaa,0xaf,0xf5,0x55,0xaa,0xff,0x00,0x55,0xf5,0x50,0x0f,0xf0,0x55,0x00,0xff,0xaa,0x5a,0xf0,0x0f,0xaf,0x5f,0xff,0xfa,0xaa,0xaa,0xff,0xff,0xf0,0xaa,0xaf,0xff,0xf5,0xaf,0xff,0xf5,0x55,0x55,0x55,0xff,0xf0,0x55,0x5f,0xff,0xfa,0xfa,0xff,0xff,0xaf,0x5f,0xff,0xfa,0xaa,0xaa,0xff,0xff,0xf0,0xaa,0xaf,0xff,0xf5,0xaf,0xff,0xf5,0x55,0x55,0x55,0xff,0xf0,0x55,0x5f,0xff,0xfa,0xfa,0xff,0xff,0xaf,0x0f,0xff,0xaa,0xa0,0xaa,0xaa,0xaa,0xa0,0xaa,0xaa,0xff,0xf0,0x0f,0xf5,0x55,0x55,0x55,0x55,0x55,0x50,0x05,0x55,0x55,0xfa,0xfa,0xaa,0xaa,0xaf,0x0f,0xff,0xaa,0xa0,0xaa,0xaa,0xaa,0xa0,0xaa,0xaa,0xff,0xf0,0x0f,0xf5,0x55,0x55,0x55,0x55,0x55,0x50,0x05,0x55,0x55,0xfa,0xfa,0xaa,0xaa,0xaf,0x0a,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0xa0,0x00,0x05,0x55,0x50,0x05,0x55,0x55,0x50,0x00,0x05,0x55,0x50,0x0f,0xff,0xff,0xf0,0x0a,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0xa0,0x00,0x05,0x55,0x50,0x05,0x55,0x55,0x50,0x00,0x05,0x55,0x50,0x0f,0xff,0xff,0xf0,0x05,0x55,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0xaf,0x55,0x50,0x0a,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x55,0x55,0x00,0x05,0x55,0x55,0xf0,0x05,0x55,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0xaf,0x55,0x50,0x0a,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x55,0x55,0x00,0x05,0x55,0x55,0xf0,0x55,0x5f,0xfa,0xa0,0x00,0x0a,0xaa,0xa0,0x0a,0xaf,0xf5,0x55,0xaa,0xff,0xf5,0x55,0x0a,0xa0,0x00,0x00,0x55,0x55,0xff,0xfa,0x55,0x55,0x55,0xff,0x55,0x5f,0xfa,0xa0,0x00,0x0a,0xaa,0xa0,0x0a,0xaf,0xf5,0x55,0xaa,0xff,0xf5,0x55,0x0a,0xa0,0x00,0x00,0x55,0x55,0xff,0xfa,0x55,0x55,0x55,0xff,0x55,0x5f,0xfa,0xaa,0x00,0x0a,0xaa,0xa0,0xaa,0xaf,0xf5,0x55,0xaa,0xff,0xf5,0x55,0x0a,0xa0,0x00,0x00,0x55,0x5f,0xff,0xfa,0x55,0x5f,0xff,0xff,0x55,0x5f,0xfa,0xaa,0x00,0x0a,0xaa,0xa0,0xaa,0xaf,0xf5,0x55,0xaa,0xff,0xf5,0x55,0x0a,0xa0,0x00,0x00,0x55,0x5f,0xff,0xfa,0x55,0x5f,0xff,0xff,0x55,0x50,0x0f,0xaa,0x00,0x00,0x00,0x00,0xaa,0xff,0x00,0x55,0xaa,0xaf,0x00,0x55,0x00,0x00,0x00,0x00,0x55,0x50,0x0f,0xaa,0x55,0xff,0xff,0xaf,0x55,0x50,0x0f,0xaa,0x00,0x00,0x00,0x00,0xaa,0xff,0x00,0x55,0xaa,0xaf,0x00,0x55,0x00,0x00,0x00,0x00,0x55,0x50,0x0f,0xaa,0x55,0xff,0xff,0xaf,0x55,0x50,0x0f,0xaa,0x00,0x00,0xaa,0x00,0xaa,0xff,0x00,0x55,0xaa,0xaf,0x00,0x55,0x00,0x0a,0xaa,0xa0,0x55,0x50,0x0f,0xaa,0xff,0xff,0xaa,0xaa,0x55,0x50,0x0f,0xaa,0x00,0x00,0xaa,0x00,0xaa,0xff,0x00,0x55,0xaa,0xaf,0x00,0x55,0x00,0x0a,0xaa,0xa0,0x55,0x50,0x0f,0xaa,0xff,0xff,0xaa,0xaa,0x55,0x55,0xff,0xfa,0xaa,0xa0,0xaa,0x00,0xaa,0xff,0x55,0x55,0xaa,0xff,0x55,0x55,0x00,0x0a,0xaa,0xa0,0x55,0x5f,0xff,0xaa,0xff,0xaa,0xaa,0xaa,0x55,0x55,0xff,0xfa,0xaa,0xa0,0xaa,0x00,0xaa,0xff,0x55,0x55,0xaa,0xff,0x55,0x55,0x00,0x0a,0xaa,0xa0,0x55,0x5f,0xff,0xaa,0xff,0xaa,0xaa,0xaa,0x55,0x55,0x5f,0xfa,0xaa,0xa0,0x00,0x00,0xaa,0xf5,0x55,0x55,0xaa,0xf5,0x55,0x55,0x00,0x00,0x00,0x00,0x05,0x5f,0xff,0xaa,0x0a,0xaa,0xaa,0xaa,0x55,0x55,0x5f,0xfa,0xaa,0xa0,0x00,0x00,0xaa,0xf5,0x55,0x55,0xaa,0xf5,0x55,0x55,0x00,0x00,0x00,0x00,0x05,0x5f,0xff,0xaa,0x0a,0xaa,0xaa,0xaa,0x05,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0x55,0x50,0x0a,0xf5,0x55,0x50,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xa0,0x00,0xaa,0xaa,0xa0,0x05,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0x55,0x50,0x0a,0xf5,0x55,0x50,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xa0,0x00,0xaa,0xaa,0xa0,0x0f,0xaa,0xaa,0x00,0x0a,0xaa,0xaa,0xa0,0x00,0x0a,0xaa,0xf0,0xaf,0xf5,0x55,0x50,0x05,0x55,0x55,0x50,0x05,0x55,0x00,0x00,0x05,0x55,0x55,0x50,0x0f,0xaa,0xaa,0x00,0x0a,0xaa,0xaa,0xa0,0x00,0x0a,0xaa,0xf0,0xaf,0xf5,0x55,0x50,0x05,0x55,0x55,0x50,0x05,0x55,0x00,0x00,0x05,0x55,0x55,0x50,0xff,0xff,0xaa,0xa0,0xaa,0xaa,0xaa,0xa0,0x0a,0xaa,0xaf,0xff,0xaf,0xf5,0x55,0x50,0x55,0x55,0x55,0x50,0x55,0x55,0xff,0xfa,0x55,0x55,0x55,0xa0,0xff,0xff,0xaa,0xa0,0xaa,0xaa,0xaa,0xa0,0x0a,0xaa,0xaf,0xff,0xaf,0xf5,0x55,0x50,0x55,0x55,0x55,0x50,0x55,0x55,0xff,0xfa,0x55,0x55,0x55,0xa0,0x5f,0xff,0xaa,0xaa,0xaf,0xff,0xaa,0xf0,0xaa,0xaa,0xff,0xf5,0xaf,0xff,0x00,0x50,0x55,0x50,0x05,0x50,0x55,0x00,0xff,0xfa,0x55,0x55,0x5a,0xa0,0x5f,0xff,0xaa,0xaa,0xaf,0xff,0xaa,0xf0,0xaa,0xaa,0xff,0xf5,0xaf,0xff,0x00,0x50,0x55,0x50,0x05,0x50,0x55,0x00,0xff,0xfa,0x55,0x55,0x5a,0xa0,0x55,0xff,0xfa,0xaa,0xff,0xff,0xff,0x50,0xaa,0xa0,0x0f,0x55,0xaa,0xff,0x00,0x55,0xff,0xf0,0x05,0x50,0x55,0x00,0xff,0xaa,0xf5,0xff,0xfa,0xa0,0x55,0xff,0xfa,0xaa,0xff,0xff,0xff,0x50,0xaa,0xa0,0x0f,0x55,0xaa,0xff,0x00,0x55,0xff,0xf0,0x05,0x50,0x55,0x00,0xff,0xaa,0xf5,0xff,0xfa,0xa0,0x55,0xf0,0x0f,0xaa,0xff,0xf0,0x05,0x50,0xaa,0xf0,0x05,0x55,0xaa,0xaf,0xff,0x55,0xff,0xff,0xff,0xf0,0x55,0xff,0xff,0xa0,0xff,0xff,0xfa,0xaa,0x55,0xf0,0x0f,0xaa,0xff,0xf0,0x05,0x50,0xaa,0xf0,0x05,0x55,0xaa,0xaf,0xff,0x55,0xff,0xff,0xff,0xf0,0x55,0xff,0xff,0xa0,0xff,0xff,0xfa,0xaa,0x55,0x50,0x0f,0xfa,0xff,0xf0,0x05,0x55,0xaf,0xff,0x55,0x55,0xaa,0xaa,0xff,0xff,0xaa,0xaa,0xff,0xf0,0xff,0xff,0xfa,0xa0,0xfa,0xff,0xaa,0xaa,0x55,0x50,0x0f,0xfa,0xff,0xf0,0x05,0x55,0xaf,0xff,0x55,0x55,0xaa,0xaa,0xff,0xff,0xaa,0xaa,0xff,0xf0,0xff,0xff,0xfa,0xa0,0xfa,0xff,0xaa,0xaa,0x55,0x55,0x5f,0xff,0x55,0x55,0x55,0x55,0xff,0xf5,0x55,0x55,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xa0,0xff,0xaa,0xaa,0xa0,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x5f,0xff,0x55,0x55,0x55,0x55,0xff,0xf5,0x55,0x55,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xa0,0xff,0xaa,0xaa,0xa0,0xaa,0xaa,0xaa,0xaa,0x05,0x55,0x55,0x50,0x05,0x55,0x55,0x55,0x05,0x55,0x55,0x50,0x0a,0xaa,0xaa,0x00,0x0a,0xaa,0xaa,0x00,0x0a,0xaa,0xaa,0x00,0x00,0xaa,0xaa,0xa0,0x05,0x55,0x55,0x50,0x05,0x55,0x55,0x55,0x05,0x55,0x55,0x50,0x0a,0xaa,0xaa,0x00,0x0a,0xaa,0xaa,0x00,0x0a,0xaa,0xaa,0x00,0x00,0xaa,0xaa,0xa0,0x00,0x50,0x0f,0x00,0x00,0x50,0x0f,0x00,0xf5,0x5f,0xf5,0xff,0xf5,0x5f,0xf5,0x5f,0x55,0xf5,0xff,0x55,0xf5,0xff,0x55,0x50,0x05,0x5f,0x55,0xf5,0x00,0x50,0x0f,0x00,0x00,0x50,0x0f,0x00,0xf5,0x5f,0xf5,0xff,0xf5,0x5f,0xf5,0x5f,0x55,0xf5,0xff,0x55,0xf5,0xff,0x55,0x50,0x05,0x5f,0x55,0xf5,0x00,0x0f,0xa0,0x00,0x00,0x0f,0xa0,0x00,0xaf,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfa,0xaf,0xff,0xff,0xf5,0x5f,0xff,0xff,0xfa,0x00,0x0f,0xa0,0x00,0x00,0x0f,0xa0,0x00,0xaf,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfa,0xaf,0xff,0xff,0xf5,0x5f,0xff,0xff,0xfa,0x00,0x05,0x50,0x00,0x00,0x05,0x50,0x00,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaf,0xfa,0xaa,0xaa,0xaa,0x00,0x05,0x50,0x00,0x00,0x05,0x50,0x00,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaf,0xfa,0xaa,0xaa,0xaa,0x00,0x50,0x05,0x00,0x00,0x50,0x05,0x00,0x0f,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0xf0,0x0f,0xa0,0x00,0x00,0x00,0x00,0x0a,0xf0,0x00,0x50,0x05,0x00,0x00,0x50,0x05,0x00,0x0f,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0xf0,0x0f,0xa0,0x00,0x00,0x00,0x00,0x0a,0xf0,0x00,0x50,0x0f,0x00,0x00,0x50,0x0f,0x00,0xaa,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xaa,0xaa,0x00,0x00,0x00,0x00,0x00,0x00,0xaa,0x00,0x50,0x0f,0x00,0x00,0x50,0x0f,0x00,0xaa,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xaa,0xaa,0x00,0x00,0x00,0x00,0x00,0x00,0xaa,0x00,0x0f,0xa0,0x00,0x00,0x0f,0xa0,0x00,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0x00,0x0f,0xa0,0x00,0x00,0x0f,0xa0,0x00,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0x00,0x05,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x55,0x55,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x55,0x55,0x50,0xf5,0x5f,0x55,0x50,0x05,0x5f,0x5f,0x55,0x05,0x55,0x55,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x55,0x55,0x50,0xf5,0x5f,0x55,0x50,0x05,0x5f,0x5f,0x55,0x5f,0xff,0xff,0xf5,0x55,0xff,0x55,0xf5,0xff,0x55,0x55,0x55,0xf5,0x55,0x5f,0x55,0x5f,0xff,0xff,0xf5,0xff,0xff,0xff,0xf5,0x5f,0xff,0xff,0xff,0x5f,0xff,0xff,0xf5,0x55,0xff,0x55,0xf5,0xff,0x55,0x55,0x55,0xf5,0x55,0x5f,0x55,0x5f,0xff,0xff,0xf5,0xff,0xff,0xff,0xf5,0x5f,0xff,0xff,0xff,0x5f,0xff,0xff,0xf5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x5f,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaf,0xfa,0xaa,0xaa,0xaa,0x5f,0xff,0xff,0xf5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x5f,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaf,0xfa,0xaa,0xaa,0xaa,0x5f,0xf0,0x0f,0xff,0xaf,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x5f,0xf0,0x0f,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5f,0xf0,0x0f,0xff,0xaf,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x5f,0xf0,0x0f,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xf0,0x0f,0xaf,0xaf,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfa,0xff,0xf0,0x0f,0xaf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xf0,0x0f,0xaf,0xaf,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfa,0xff,0xf0,0x0f,0xaf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xfa,0xaa,0xaf,0xaa,0xaa,0xff,0xaf,0xff,0xaf,0xfa,0xff,0xfa,0xfa,0xfa,0xaa,0xff,0xaa,0xaa,0xaf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xfa,0xaa,0xaf,0xaa,0xaa,0xff,0xaf,0xff,0xaf,0xfa,0xff,0xfa,0xfa,0xfa,0xaa,0xff,0xaa,0xaa,0xaf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfa,0xaa,0xaa,0xaf,0xaa,0x0a,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xa0,0xfa,0xaa,0xaa,0xaf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfa,0xaa,0xaa,0xaf,0xaa,0x0a,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xa0,0xfa,0xaa,0xaa,0xaf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x5f,0xf5,0x5f,0x55,0x5f,0xff,0x55,0x5f,0x55,0xff,0x50,0x05,0x5f,0xf5,0x5f,0x5f,0x55,0xff,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x5f,0xf5,0x5f,0x55,0x5f,0xff,0x55,0x5f,0x55,0xff,0x50,0x05,0x5f,0xf5,0x5f,0x5f,0x55,0xff,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x5f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x5f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfa,0xff,0xaf,0xaf,0xfa,0xaf,0xaf,0xff,0xfa,0xaa,0xff,0xaa,0xaa,0xff,0xaf,0xaf,0xfa,0xaa,0xff,0xaf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfa,0xff,0xaf,0xaf,0xfa,0xaf,0xaf,0xff,0xfa,0xaa,0xff,0xaa,0xaa,0xff,0xaf,0xaf,0xfa,0xaa,0xff,0xaf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xa0,0x0a,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xaa,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0xaa,0x00,0x00,0xaa,0xa0,0x00,0x00,0x0a,0xaa,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xaa,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0xaa,0x00,0x00,0xaa,0xa0,0x00,0x00,0x0a,0xaa,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa0,0x00,0x00,0x0a,0x00,0x00,0x00,0x00,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa0,0x00,0x00,0x0a,0x00,0x00,0x00,0x00,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00];

// coin
const COIN_WIDTH: u32 = 96;
const COIN_HEIGHT: u32 = 16;
const COIN_FLAGS: u32 = 1; // BLIT_2BPP
// 6 sprites. Each are 16x16.
static COIN: [u8; 384] = [ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x50,0x00,0x00,0x05,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x50,0x00,0x00,0x05,0x50,0x00,0x00,0x05,0x50,0x00,0x00,0x05,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x50,0x00,0x00,0x05,0x50,0x00,0x00,0x5a,0xa5,0x00,0x00,0x5a,0xa5,0x00,0x00,0x05,0x50,0x00,0x00,0x05,0x50,0x00,0x00,0x5a,0xa5,0x00,0x00,0x5a,0xa5,0x00,0x00,0x5a,0xa5,0x00,0x00,0x5a,0xa5,0x00,0x00,0x05,0x50,0x00,0x00,0x05,0x50,0x00,0x00,0x5a,0xa5,0x00,0x00,0x5a,0xa5,0x00,0x00,0x5a,0xf5,0x00,0x00,0x5a,0xa5,0x00,0x00,0x55,0xa5,0x00,0x00,0x5a,0x55,0x00,0x00,0x5a,0x55,0x00,0x00,0x5a,0xa5,0x00,0x00,0x5a,0xf5,0x00,0x00,0x5a,0xa5,0x00,0x00,0x55,0xa5,0x00,0x00,0x5a,0x55,0x00,0x00,0x5a,0x55,0x00,0x00,0x5a,0xa5,0x00,0x00,0x5f,0xf5,0x00,0x00,0x5a,0xf5,0x00,0x00,0x5a,0xf5,0x00,0x00,0x55,0xf5,0x00,0x00,0x55,0xa5,0x00,0x00,0x5a,0xf5,0x00,0x00,0x5f,0xf5,0x00,0x00,0x5a,0xf5,0x00,0x00,0x5a,0xf5,0x00,0x00,0x55,0xf5,0x00,0x00,0x55,0xa5,0x00,0x00,0x5a,0xf5,0x00,0x00,0x05,0x50,0x00,0x00,0x5f,0xf5,0x00,0x00,0x5f,0xf5,0x00,0x00,0x5f,0xf5,0x00,0x00,0x5a,0xf5,0x00,0x00,0x05,0x50,0x00,0x00,0x05,0x50,0x00,0x00,0x5f,0xf5,0x00,0x00,0x5f,0xf5,0x00,0x00,0x5f,0xf5,0x00,0x00,0x5a,0xf5,0x00,0x00,0x05,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x50,0x00,0x00,0x05,0x50,0x00,0x00,0x05,0x50,0x00,0x00,0x05,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x50,0x00,0x00,0x05,0x50,0x00,0x00,0x05,0x50,0x00,0x00,0x05,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ];

static COIN_CYCLE : AnimationCycle = AnimationCycle {
   current_time_in_animation_seconds: 0.0,
   animation_length_seconds: 3.0,
   animation_sprites: 6,
   starting_animation_x: 0,
   offset_between_sprites: 16,
   repeat_cycle: true,
};
// door
const DOOR_WIDTH: u32 = 128;
const DOOR_HEIGHT: u32 = 16;
const DOOR_FLAGS: u32 = 1; // BLIT_2BPP
// 8 sprites, each 16x16
static DOOR: [u8; 512] = [0x05,0x55,0x55,0x50,0x05,0x55,0x55,0x50,0x05,0x55,0x55,0x50,0x05,0x55,0x55,0x50,0x05,0x55,0x55,0x50,0x05,0x55,0x55,0x50,0x05,0x55,0x55,0x50,0x05,0x55,0x55,0x50,0x05,0x55,0x55,0x50,0x05,0x55,0x55,0x50,0x05,0x55,0x55,0x50,0x05,0x55,0x55,0x50,0x05,0x55,0x55,0x50,0x05,0x55,0x55,0x50,0x05,0x55,0x55,0x50,0x05,0x55,0x55,0x50,0x5a,0xaa,0xaa,0xa5,0x5a,0xaa,0xaa,0xa5,0x5a,0xaa,0xaa,0xa5,0x5a,0xaa,0xaa,0xa5,0x5a,0xaa,0xaa,0xa5,0x5a,0xaa,0xaa,0xa5,0x5a,0xaa,0xaa,0xa5,0x5a,0xaa,0xaa,0xa5,0x5a,0xaa,0xaa,0xa5,0x5a,0xaa,0xaa,0xa5,0x5a,0xaa,0xaa,0xa5,0x5a,0xaa,0xaa,0xa5,0x5a,0xaa,0xaa,0xa5,0x5a,0xaa,0xaa,0xa5,0x5a,0xaa,0xaa,0xa5,0x5a,0xaa,0xaa,0xa5,0x5a,0xff,0xff,0xa5,0x5a,0xfa,0xaf,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0xff,0xff,0xa5,0x5a,0xfa,0xaf,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0xfa,0xaf,0xa5,0x5a,0xff,0xff,0xa5,0x5a,0xfa,0xaf,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0xfa,0xaf,0xa5,0x5a,0xff,0xff,0xa5,0x5a,0xfa,0xaf,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0xff,0xff,0xa5,0x5a,0xfa,0xaf,0xa5,0x5a,0xff,0xff,0xa5,0x5a,0xfa,0xaf,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0xff,0xff,0xa5,0x5a,0xfa,0xaf,0xa5,0x5a,0xff,0xff,0xa5,0x5a,0xfa,0xaf,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0xfa,0xaf,0xa5,0x5a,0xfa,0xaf,0xa5,0x5a,0xfa,0xaf,0xa5,0x5a,0xff,0xff,0xa5,0x5a,0xfa,0xaf,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0xfa,0xaf,0xa5,0x5a,0xfa,0xaf,0xa5,0x5a,0xfa,0xaf,0xa5,0x5a,0xff,0xff,0xa5,0x5a,0xfa,0xaf,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x5a,0x00,0x00,0xa5,0x50,0xfa,0xaf,0x05,0x50,0xff,0xff,0x05,0x50,0xfa,0xaf,0x05,0x50,0xfa,0xaf,0x05,0x50,0xff,0xff,0x05,0x50,0xfa,0xaf,0x05,0x50,0x00,0x00,0x05,0x50,0x00,0x00,0x05,0x50,0xfa,0xaf,0x05,0x50,0xff,0xff,0x05,0x50,0xfa,0xaf,0x05,0x50,0xfa,0xaf,0x05,0x50,0xff,0xff,0x05,0x50,0xfa,0xaf,0x05,0x50,0x00,0x00,0x05,0x50,0x00,0x00,0x05,0x50,0xaa,0xaa,0x05,0x50,0xaa,0xaa,0x05,0x50,0xaa,0xaa,0x05,0x50,0xaa,0xaa,0x05,0x50,0xaa,0xaa,0x05,0x50,0xaa,0xaa,0x05,0x50,0xaa,0xaa,0x05,0x50,0x00,0x00,0x05,0x50,0xaa,0xaa,0x05,0x50,0xaa,0xaa,0x05,0x50,0xaa,0xaa,0x05,0x50,0xaa,0xaa,0x05,0x50,0xaa,0xaa,0x05,0x50,0xaa,0xaa,0x05,0x50,0xaa,0xaa,0x05,0x50,0x00,0x00,0x05];

static DOOR_CYCLE : AnimationCycle = AnimationCycle {
   current_time_in_animation_seconds: 0.0,
   animation_length_seconds: 1.5,
   animation_sprites: 8,
   starting_animation_x: 0,
   offset_between_sprites: 16,
   repeat_cycle: false,
};
//
