struct DynArray<T> {
   buf: &T,
   length: usize,
   capacity: usize,
}

proc _da_next_capacity(cap: usize) -> usize {
    if cap == 0 {
        return 4;
    }
    return cap * 2;
}

proc da_append<T>(x: &DynArray<T>, item: T) {
    if x~.length == x~.capacity {
        let old_ptr = x~.buf;
        let desired_capacity = _da_next_capacity(x~.capacity);
        let new_block = malloc(sizeof$<T>() * desired_capacity, alignof$<T>());
        assert(new_block.size >= desired_capacity * sizeof$<T>()); 
        x~.capacity = new_block.size / sizeof$<T>();
        x~.buf = new_block.buf transmute &unit transmute &T; 
        memcpy(x~.buf, old_ptr, x~.length * sizeof$<T>());
        free(old_ptr transmute &u8);
    }
    (((x~.buf transmute usize) + sizeof$<T>() * x~.length) transmute &T)~ = item;
    x~.length = x~.length + 1;
}

proc da_get<T>(x: &DynArray<T>, index: usize) -> T{
    return (((x~.buf transmute usize) + sizeof$<T>() * index) transmute &T)~;
}

proc da_init<T>() -> DynArray<T> {
    return DynArray$<T> {
        buf: 0 transmute &T,
        length: 0,
        capacity: 0,
    };
}

proc da_free<T>(x: &DynArray<T>) {
    free(x~.buf transmute &u8);
}