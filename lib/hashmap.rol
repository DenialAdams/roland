struct HashMap<K, V> {
    hash: proc(&K) -> usize,
    eq: proc(&V, &V) -> bool,
    len: usize,
    capacity: usize,
    cells: &_hm_Cell<V>,
}

struct _hm_Cell<V> {
    present: bool,
    val: V,
}

proc hash_bytes<K>(key: &K) -> usize {
    let byte_view = key transmute &u8;
    // TODO: fnv
    let sum = 0;
    for i in 0..sizeof$<K>() {
        sum = sum + _hm_offset_ptr_items(byte_view, i)~ as usize;
    }
    return sum;
}

proc eq_bytes<V>(a: &V, b: &V) -> bool {
    let bytes_a = a transmute &V;
    let bytes_b = b transmute &V;
    for i in 0..sizeof$<V>() {
        if _hm_offset_ptr_items(bytes_a, i)~ != _hm_offset_ptr_items(bytes_b, i)~ {
            return false;
        }
    }
    return true;
}

proc hm_init<K, V>(hash: proc(&K) -> usize, eq: proc(&V, &V) -> bool) -> HashMap<K, V> {
    return HashMap$<K, V> {
        hash: hash,
        eq: eq,
        len: 0,
        capacity: 0,
        cells: 0 transmute &_hm_Cell<V>,
    };
}

proc hm_lookup<K, V>(m: &HashMap<K, V>, k: K) -> &V {
    let hash = m.hash(k);
    let slot = hash % m.capacity;
}

proc _hm_offset_ptr_items<T>(ptr: &T, items: usize) -> &T {
  return (ptr transmute usize + items * sizeof$<T>()) transmute &T;
}
