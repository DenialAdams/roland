struct HashMap<K, V> {
    hash: proc(&K) -> usize,
    eq: proc(&K, &K) -> bool,
    len: usize,
    capacity: usize,
    cells: &_hm_Cell<K, V>,
}

enum _hm_Cell_State {
    Present,
    Deleted,
    Absent,
}

struct _hm_Cell<K, V> {
    state: _hm_Cell_State,
    key: K,
    val: V,
}

proc hash_bytes<K>(key: &K) -> usize {
    let byte_view = key transmute &u8;
    // TODO: fnv
    let sum = 0;
    for i in 0..sizeof$<K>() {
        sum = sum + _hm_offset_ptr_items(byte_view, i)~ as usize;
    }
    return sum;
}

proc eq_bytes<V>(a: &V, b: &V) -> bool {
    for i in 0..sizeof$<V>() {
        if _hm_offset_ptr_items(a, i)~ != _hm_offset_ptr_items(b, i)~ {
            return false;
        }
    }
    return true;
}

proc hm_init<K, V>(hash: proc(&K) -> usize, eq: proc(&K, &K) -> bool) -> HashMap<K, V> {
    return HashMap$<K, V> {
        hash: hash,
        eq: eq,
        len: 0,
        capacity: 0,
        cells: 0 transmute &_hm_Cell<K, V>,
    };
}

proc hm_lookup<K, V>(m: &HashMap<K, V>, k: &K) -> &V {
    if m.capacity == 0 {
        return 0 transmute &V;
    }
    let hash = m.hash(k);
    let slot_index = hash % m.capacity;
    loop {
        let slot = _hm_offset_ptr_items(m.cells, slot_index);
        if slot~.state == _hm_Cell_State::Absent {
            return 0 transmute &V;
        }
        if m.eq(&slot~.key, k){
            return &slot~.val;
        }
        if slot_index == m.capacity - 1 {
            slot_index = slot_index + 1;
        } else {
            slot_index = 0;
        }
    }
}

proc _hm_offset_ptr_items<T>(ptr: &T, items: usize) -> &T {
  return (ptr transmute usize + items * sizeof$<T>()) transmute &T;
}
