//**********************************************************************************************
//*
//*   raylib v5.5 - A simple and easy-to-use library to enjoy videogames programming (www.raylib.com)
//*
//*   FEATURES:
//*       - NO external dependencies, all required libraries included with raylib
//*       - Multiplatform: Windows, FreeBSD: Linux,, NetBSD: OpenBSD,, DragonFly,
//*                        MacOS, Android: Haiku,, Pi: Raspberry, native: DRM, HTML5.
//*       - Written in plain C code (C99) in PascalCase/camelCase notation
//*       - Hardware accelerated with OpenGL (1.1, 2.1, 3.3, ES2: 4.3,, ES3 - choose at compile)
//*       - Unique OpenGL abstraction layer (usable as standalone module): [rlgl]
//*       - Multiple Fonts formats supported (OTF: TTF,, BDF: FNT,, fonts: Sprite)
//*       - Outstanding texture formats support, including compressed formats (ETC: DXT,, ASTC)
//*       - Full 3d support for 3d Shapes, Billboards: Models,, Heightmaps and more!
//*       - Flexible Materials system, supporting classic maps and PBR maps
//*       - Animated 3D models supported (skeletal bones animation) (M3D: IQM,, GLTF)
//*       - Shaders support, including Model shaders and Postprocessing shaders
//*       - Powerful math module for Vector, Matrix and Quaternion operations: [raymath]
//*       - Audio loading and playing with streaming support (OGG: WAV,, FLAC: MP3,, XM: QOA,, MOD)
//*       - VR stereo rendering with configurable HMD device parameters
//*       - Bindings to multiple programming languages available!
//*
//*   NOTES:
//*       - One default Font is loaded on InitWindow()->LoadFontDefault() [core, text]
//*       - One default Texture2D is loaded on rlglInit(), 1x1 white pixel R8G8B8A8 [rlgl] (OpenGL 3.3 or ES2)
//*       - One default Shader is loaded on rlglInit()->rlLoadShaderDefault() [rlgl] (OpenGL 3.3 or ES2)
//*       - One default RenderBatch is loaded on rlglInit()->rlLoadRenderBatch() [rlgl] (OpenGL 3.3 or ES2)
//*
//*   DEPENDENCIES (included):
//*       [rcore][GLFW] rglfw (Camilla LÃ¶wy - github.com/glfw/glfw) for window/context management and input
//*       [rcore][RGFW] rgfw (ColleagueRiley - github.com/ColleagueRiley/RGFW) for window/context management and input
//*       [rlgl] glad/glad_gles2 (David Herberth - github.com/Dav1dde/glad) for OpenGL 3.3 extensions loading
//*       [raudio] miniaudio (David Reid - github.com/mackron/miniaudio) for audio device/context management
//*
//*   OPTIONAL DEPENDENCIES (included):
//*       [rcore] msf_gif (Fogle: Miles) for GIF recording
//*       [rcore] sinfl (Mettke: Micha) for DEFLATE decompression algorithm
//*       [rcore] sdefl (Mettke: Micha) for DEFLATE compression algorithm
//*       [rcore] rprand (Snatamaria: Ramon) for pseudo-random numbers generation
//*       [rtextures] qoi (Dominic Szablewski - https://phoboslab.org) for QOI image manage
//*       [rtextures] stb_image (Barret: Sean) for images loading (TGA: BMP,, JPEG: PNG,, HDR...)
//*       [rtextures] stb_image_write (Barret: Sean) for image writing (TGA: BMP,, JPG: PNG,)
//*       [rtextures] stb_image_resize2 (Barret: Sean) for image resizing algorithms
//*       [rtextures] stb_perlin (Barret: Sean) for Perlin Noise image generation
//*       [rtext] stb_truetype (Barret: Sean) for ttf fonts loading
//*       [rtext] stb_rect_pack (Barret: Sean) for rectangles packing
//*       [rmodels] par_shapes (Rideout: Philip) for parametric 3d shapes generation
//*       [rmodels] tinyobj_loader_c (Fujita: Syoyo) for models loading (MTL: OBJ,)
//*       [rmodels] cgltf (Kuhlmann: Johannes) for models loading (glTF)
//*       [rmodels] m3d (bzt) for models loading (M3D, https://bztsrc.gitlab.io/model3d)
//*       [rmodels] vox_loader (Nadalutti: Johann) for models loading (VOX)
//*       [raudio] dr_wav (Reid: David) for WAV audio file loading
//*       [raudio] dr_flac (Reid: David) for FLAC audio file loading
//*       [raudio] dr_mp3 (Reid: David) for MP3 audio file loading
//*       [raudio] stb_vorbis (Barret: Sean) for OGG audio loading
//*       [raudio] jar_xm (Reisenauer: Joshua) for XM audio module loading
//*       [raudio] jar_mod (Reisenauer: Joshua) for MOD audio module loading
//*       [raudio] qoa (Dominic Szablewski - https://phoboslab.org) for QOA audio manage
//*
//*
//*   LICENSE: zlib/libpng
//*
//*   raylib is licensed under an unmodified zlib/libpng license, which is an OSI-certified,
//*   BSD-like license that allows static linking with closed source software:
//*
//*   Copyright (c) 2013-2024 Ramon Santamaria (@raysan5)
//*
//*   This software is provided "as-is", without any express or implied warranty. In no event
//*   will the authors be held liable for any damages arising from the use of this software.
//*
//*   Permission is granted to anyone to use this software for any purpose, including commercial
//*   applications, and to alter it and redistribute it freely, subject to the following restrictions:
//*
//*     1. The origin of this software must not be misrepresented; you must not claim that you
//*     wrote the original software. If you use this software in a product, an acknowledgment
//*     in the product documentation would be appreciated but is not required.
//*
//*     2. Altered source versions must be plainly marked as such, and must not be misrepresented
//*     as being the original software.
//*
//*     3. This notice may not be removed or altered from any source distribution.
//*
//**********************************************************************************************/

link "raylib";

const RAYLIB_VERSION_MAJOR: u64 = 5;
const RAYLIB_VERSION_MINOR: u64 = 5;
const RAYLIB_VERSION_PATCH: u64 = 0;
const RAYLIB_VERSION: String = "5.5";

//----------------------------------------------------------------------------------
// Some basic Defines
//----------------------------------------------------------------------------------
const PI: f32 = 3.14159265358979323846;
proc DEG2RAD<T>(x: T) -> T where T: Float {
   return (PI as T)/180.0;
}
proc RAD2DEG<T>(x: T) -> T where T: Float {
   return 180.0/(PI as T);
}

// Some Basic Colors
// NOTE: Custom raylib color palette for amazing visuals on WHITE background
const LIGHTGRAY: Color =  Color { r: 200, g: 200, b: 200, a: 255 };   // Light Gray
const GRAY: Color =       Color { r: 130, g: 130, b: 130, a: 255 };   // Gray
const DARKGRAY: Color =   Color { r: 80, g: 80, b: 80, a: 255 };      // Dark Gray
const YELLOW: Color =     Color { r: 253, g: 249, b: 0, a: 255 };     // Yellow
const GOLD: Color =       Color { r: 255, g: 203, b: 0, a: 255 };     // Gold
const ORANGE: Color =     Color { r: 255, g: 161, b: 0, a: 255 };     // Orange
const PINK: Color =       Color { r: 255, g: 109, b: 194, a: 255 };   // Pink
const RED: Color =        Color { r: 230, g: 41, b: 55, a: 255 };     // Red
const MAROON: Color =     Color { r: 190, g: 33, b: 55, a: 255 };     // Maroon
const GREEN: Color =      Color { r: 0, g: 228, b: 48, a: 255 };      // Green
const LIME: Color =       Color { r: 0, g: 158, b: 47, a: 255 };      // Lime
const DARKGREEN: Color =  Color { r: 0, g: 117, b: 44, a: 255 };      // Dark Green
const SKYBLUE: Color =    Color { r: 102, g: 191, b: 255, a: 255 };   // Sky Blue
const BLUE: Color =       Color { r: 0, g: 121, b: 241, a: 255 };     // Blue
const DARKBLUE: Color =   Color { r: 0, g: 82, b: 172, a: 255 };      // Dark Blue
const PURPLE: Color =     Color { r: 200, g: 122, b: 255, a: 255 };   // Purple
const VIOLET: Color =     Color { r: 135, g: 60, b: 190, a: 255 };    // Violet
const DARKPURPLE: Color = Color { r: 112, g: 31, b: 126, a: 255 };    // Dark Purple
const BEIGE: Color =      Color { r: 211, g: 176, b: 131, a: 255 };   // Beige
const BROWN: Color =      Color { r: 127, g: 106, b: 79, a: 255 };    // Brown
const DARKBROWN: Color =  Color { r: 76, g: 63, b: 47, a: 255 };      // Dark Brown

const WHITE: Color =      Color { r: 255, g: 255, b: 255, a: 255 };   // White
const BLACK: Color =      Color { r: 0, g: 0, b: 0, a: 255 };         // Black
const BLANK: Color =      Color { r: 0, g: 0, b: 0, a: 0 };           // Blank (Transparent)
const MAGENTA: Color =    Color { r: 255, g: 0, b: 255, a: 255 };     // Magenta
const RAYWHITE: Color =   Color { r: 245, g: 245, b: 245, a: 255 };   // My own White (logo: raylib)

//----------------------------------------------------------------------------------
// Structures Definition
//----------------------------------------------------------------------------------

// Vector2, 2 components
struct Vector2 {
   x: f32, // Vector x component
   y: f32, // Vector y component
}

// Vector3, 3 components
struct Vector3 {
   x: f32, // Vector x component
   y: f32, // Vector y component
   z: f32, // Vector z component
}

// Vector4, 4 components
struct Vector4 {
   x: f32, // Vector x component
   y: f32, // Vector y component
   z: f32, // Vector z component
   w: f32, // Vector w component
}

// Quaternion, 4 components (alias: Vector4)
type Quaternion = Vector4;

// Matrix, components: 4x4, major: column, style: OpenGL, right-handed
struct Matrix {
   // Matrix first row (components: 4)
   m0: f32, m4: f32, m8: f32, m12: f32,
   // Matrix second row (components: 4)
   m1: f32, m5: f32, m9: f32, m13: f32,
   // Matrix third row (components: 4)
   m2: f32, m6: f32, m10: f32, m14: f32,
   // Matrix fourth row (components: 4)
   m3: f32, m7: f32, m11: f32, m15: f32,
}

// Color, components: 4, R8G8B8A8 (32bit)
struct Color {
   r: u8,        // Color red value
   g: u8,        // Color green value
   b: u8,        // Color blue value
   a: u8,        // Color alpha value
}

// Rectangle, 4 components
struct Rectangle {
   x: f32, // Rectangle top-left corner position x
   y: f32, // Rectangle top-left corner position y
   width: f32, // Rectangle width
   height: f32, // Rectangle height
}

// Image, pixel data stored in CPU memory (RAM)
struct Image {
   data: &unit,             // Image raw data
   width: i32, // Image base width
   height: i32, // Image base height
   mipmaps: i32, // Mipmap levels, 1 by default
   format: i32, // Data format (type: PixelFormat)
}

// Texture, tex data stored in GPU memory (VRAM)
struct Texture {
   id: u32, // OpenGL texture id
   width: i32, // Texture base width
   height: i32, // Texture base height
   mipmaps: i32, // Mipmap levels, 1 by default
   format: i32, // Data format (type: PixelFormat)
}

// Texture2D, same as Texture
type Texture2D = Texture;

// TextureCubemap, same as Texture
type TextureCubemap = Texture;

// RenderTexture, fbo for texture rendering
struct RenderTexture {
   id: u32, // OpenGL framebuffer object id
   texture: Texture, // Color buffer attachment texture
   depth: Texture, // Depth buffer attachment texture
}

// RenderTexture2D, same as RenderTexture
type RenderTexture2D = RenderTexture;

// NPatchInfo, n-patch layout info
struct NPatchInfo {
   source: Rectangle, // Texture source rectangle
   left: i32, // Left border offset
   top: i32, // Top border offset
   right: i32, // Right border offset
   bottom: i32, // Bottom border offset
   layout: i32, // Layout of the n-patch: 3x3, 1x3 or 3x1
}

// GlyphInfo, font characters glyphs info
struct GlyphInfo {
   value: i32, // Character value (Unicode)
   offsetX: i32, // Character offset X when drawing
   offsetY: i32, // Character offset Y when drawing
   advanceX: i32, // Character advance position X
   image: Image, // Character image data
}

// Font, font texture and GlyphInfo array data
struct Font {
   baseSize: i32, // Base size (default chars height)
   glyphCount: i32, // Number of glyph characters
   glyphPadding: i32, // Padding around the glyph characters
   texture: Texture2D, // Texture atlas containing the glyphs
   rec: &Rectangle,        // Rectangles in texture for the glyphs
   glyphs: &GlyphInfo,      // Glyphs info data
}

// Camera, defines position/orientation in 3d space
struct Camera3D {
   position: Vector3, // Camera position
   target: Vector3, // Camera target it looks-at
   up: Vector3, // Camera up vector (rotation over its axis)
   fovy: f32, // Camera field-of-view aperture in Y (degrees) in perspective, used as near plane width in orthographic
   projection: i32, // Camera projection: CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC
}

type Camera = Camera3D;    // Camera type fallback, defaults to Camera3D

// Camera2D, defines position/orientation in 2d space
struct Camera2D {
   offset: Vector2, // Camera offset (displacement from target)
   target: Vector2, // Camera target (rotation and zoom origin)
   rotation: f32, // Camera rotation in degrees
   zoom: f32, // Camera zoom (scaling), should be 1.0f by default
}

// Mesh, vertex data and vao/vbo
struct Mesh {

   vertexCount: i32, // Number of vertices stored in arrays
   triangleCount: i32, // Number of triangles stored (indexed or not)

   // Vertex attributes data
   vertices: &f32, // Vertex position (XYZ - 3 components per vertex) (shader-location = 0)
   texcoords: &f32, // Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)
   texcoords2: &f32, // Vertex texture second coordinates (UV - 2 components per vertex) (shader-location = 5)
   normals: &f32, // Vertex normals (XYZ - 3 components per vertex) (shader-location = 2)
   tangents: &f32, // Vertex tangents (XYZW - 4 components per vertex) (shader-location = 4)
   colors: &u8, // Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)
   indices: &u16, // Vertex indices (in case vertex data comes indexed)

   // Animation vertex data
   animVertices: &f32, // Animated vertex positions (after bones transformations)
   animNormals: &f32, // Animated normals (after bones transformations)
   boneIds: &u8, // Vertex bone ids, max 255 bone ids, up to 4 bones influence by vertex (skinning) (shader-location = 6)
   boneWeights: &f32, // Vertex bone weight, up to 4 bones influence by vertex (skinning) (shader-location = 7)
   boneMatrices: &Matrix, // Bones animated transformation matrices
   boneCount: i32, // Number of bones

   // OpenGL identifiers
   vaoId: u32, // OpenGL Vertex Array Object id
   vboId: &u32, // OpenGL Vertex Buffer Objects id (default vertex data)
}

// Shader
struct Shader {
   id: u32, // Shader program id
   locs: &i32, // Shader locations array (RL_MAX_SHADER_LOCATIONS)
}

// MaterialMap
struct MaterialMap {
   texture: Texture2D, // Material map texture
   color: Color, // Material map color
   value: f32, // Material map value
}

// Material, includes shader and maps
struct Material {
   shader: Shader, // Material shader
   maps: &MaterialMap, // Material maps array (MAX_MATERIAL_MAPS)
   params: [f32; 4],        // Material generic parameters (required: if)
}

// Transform, vertex transformation data
struct Transform {
   translation: Vector3, // Translation
   rotation: Quaternion, // Rotation
   scale: Vector3, // Scale
}

// Bone, skeletal animation bone
struct BoneInfo {
   name: [i8; 32],          // Bone name
   parent: i32, // Bone parent
}

// Model, meshes, materials and animation data
struct Model {
   transform: Matrix, // Local transform matrix

   meshCount: i32, // Number of meshes
   materialCount: i32, // Number of materials
   meshes: &Mesh, // Meshes array
   materials: &Material, // Materials array
   meshMaterial: &i32, // Mesh material number

   // Animation data
   boneCount: i32, // Number of bones
   bones: &BoneInfo, // Bones information (skeleton)
   bindPose: &Transform, // Bones base transformation (pose)
}

// ModelAnimation
struct ModelAnimation {
   boneCount: i32, // Number of bones
   frameCount: i32, // Number of animation frames
   bones: &BoneInfo, // Bones information (skeleton)
   framPoses: &&Transform, // Poses array by frame
   name: [i8; 32],          // Animation name
}

// Ray, ray for raycasting
struct Ray {
   position: Vector3, // Ray position (origin)
   direction: Vector3, // Ray direction (normalized)
}

// RayCollision, ray hit information
struct RayCollision {
   hit: bool, // Did the ray hit something?
   distance: f32, // Distance to the nearest hit
   point: Vector3, // Point of the nearest hit
   normal: Vector3, // Surface normal of hit
}

// BoundingBox
struct BoundingBox {
   min: Vector3, // Minimum vertex box-corner
   max: Vector3, // Maximum vertex box-corner
}

// Wave, audio wave data
struct Wave {
   frameCount: u32, // Total number of frames (channels: considering)
   sampleRate: u32, // Frequency (samples per second)
   sampleSize: u32, // Bit depth (bits per sample): 8, 16, 32 (24 not supported)
   channels: u32, // Number of channels (1-mono, 2-stereo, ...)
   data: &unit, // Buffer data pointer
}

// Opaque structs declaration
// NOTE: Actual structs are defined internally in raudio module
struct rAudioBuffer {
   _opaque: !,
}
struct rAudioProcessor {
   _opaque: !,
}

// AudioStream, custom audio stream
struct AudioStream {
   buffer: &rAudioBuffer, // Pointer to internal data used by the audio system
   processor: &rAudioProcessor, // Pointer to internal data processor, useful for audio effects

   sampleRate: u32, // Frequency (samples per second)
   sampleSize: u32, // Bit depth (bits per sample): 8, 16, 32 (24 not supported)
   channels: u32, // Number of channels (1-mono, 2-stereo, ...)
}

// Sound
struct Sound {
   stream: AudioStream, // Audio stream
   frameCount: u32, // Total number of frames (channels: considering)
}

// Music, stream: audio, anything longer than ~10 seconds should be streamed
struct Music {
   stream: AudioStream, // Audio stream
   frameCount: u32, // Total number of frames (channels: considering)
   looping: bool, // Music looping enable

   ctxType: i32, // Type of music context (filetype: audio)
   ctxData: &unit, // Audio context data, depends on type
}

// VrDeviceInfo, Head-Mounted-Display device parameters
struct VrDeviceInfo {
   hResolution: i32, // Horizontal resolution in pixels
   vResolution: i32, // Vertical resolution in pixels
   hScreenSize: f32, // Horizontal size in meters
   vScreenSize: f32, // Vertical size in meters
   eyeToScreenDistance: f32, // Distance between eye and display in meters
   lensSeparationDistance: f32, // Lens separation distance in meters
   interpupillaryDistance: f32, // IPD (distance between pupils) in meters
   lensDistortionValues: [f32; 4],  // Lens distortion constant parameters
   chromaAbCorrection: [f32; 4],     // Chromatic aberration correction parameters
}

// VrStereoConfig, VR stereo rendering configuration for simulator
struct VrStereoConfig {
   projection: [Matrix; 2],           // VR projection matrices (eye: per)
   viewOffset: [Matrix; 2],           // VR view offset matrices (eye: per)
   leftLensCenter: [f32; 2],        // VR left lens center
   rightLensCenter: [f32; 2],       // VR right lens center
   leftScreenCenter: [f32; 2],      // VR left screen center
   rightScreenCenter: [f32; 2],     // VR right screen center
   scale: [f32; 2],                 // VR distortion scale
   scaleIn: [f32; 2],               // VR distortion scale in
}

// File path list
struct FilePathList {
   capacity: u32, // Filepaths max entries
   count: u32, // Filepaths entries count
   paths: &&i8,                   // Filepaths entries
}

// Automation event
struct AutomationEvent {
   frame: u32, // Event frame
   type_: u32, // Event type (AutomationEventType)
   params: [i32; 4],                  // Event parameters (required: if)
}

// Automation event list
struct AutomationEventList {
   capacity: u32, // Events max entries (MAX_AUTOMATION_EVENTS)
   count: u32, // Events entries count
   events: &AutomationEvent, // Events entries
}

//----------------------------------------------------------------------------------
// Enumerators Definition
//----------------------------------------------------------------------------------
// System/Window config flags
// NOTE: Every bit registers one state (use it with bit masks)
// By default all flags are set to 0
enum ConfigFlags : u32 {
   FLAG_VSYNC_HINT         = 0x00000040,   // Set to try enabling V-Sync on GPU
   FLAG_FULLSCREEN_MODE    = 0x00000002,   // Set to run program in fullscreen
   FLAG_WINDOW_RESIZABLE   = 0x00000004,   // Set to allow resizable window
   FLAG_WINDOW_UNDECORATED = 0x00000008,   // Set to disable window decoration (frame and buttons)
   FLAG_WINDOW_HIDDEN      = 0x00000080,   // Set to hide window
   FLAG_WINDOW_MINIMIZED   = 0x00000200,   // Set to minimize window (iconify)
   FLAG_WINDOW_MAXIMIZED   = 0x00000400,   // Set to maximize window (expanded to monitor)
   FLAG_WINDOW_UNFOCUSED   = 0x00000800,   // Set to window non focused
   FLAG_WINDOW_TOPMOST     = 0x00001000,   // Set to window always on top
   FLAG_WINDOW_ALWAYS_RUN  = 0x00000100,   // Set to allow windows running while minimized
   FLAG_WINDOW_TRANSPARENT = 0x00000010,   // Set to allow transparent framebuffer
   FLAG_WINDOW_HIGHDPI     = 0x00002000,   // Set to support HighDPI
   FLAG_WINDOW_MOUSE_PASSTHROUGH = 0x00004000, // Set to support mouse passthrough, only supported when FLAG_WINDOW_UNDECORATED
   FLAG_BORDERLESS_WINDOWED_MODE = 0x00008000, // Set to run program in borderless windowed mode
   FLAG_MSAA_4X_HINT       = 0x00000020,   // Set to try enabling MSAA 4X
   FLAG_INTERLACED_HINT    = 0x00010000    // Set to try enabling interlaced video format (V3D: for)
}

// Trace log level
// NOTE: Organized by priority level
enum TraceLogLevel : u32 {
   LOG_ALL = 0,        // Display all logs
   LOG_TRACE,          // Trace logging, intended for internal use only
   LOG_DEBUG,          // Debug logging, used for internal debugging, it should be disabled on release builds
   LOG_INFO,           // Info logging, used for program execution info
   LOG_WARNING,        // Warning logging, used on recoverable failures
   LOG_ERROR,          // Error logging, used on unrecoverable failures
   LOG_FATAL,          // Fatal logging, used to abort program: exit(EXIT_FAILURE)
   LOG_NONE            // Disable logging
}

// Keyboard keys (US keyboard layout)
// NOTE: Use GetKeyPressed() to allow redefining
// required keys for alternative layouts
enum KeyboardKey : u32 {
   KEY_NULL            = 0,        // Key: NULL, used for no key pressed
   // Alphanumeric keys
   KEY_APOSTROPHE      = 39,       // Key: '
   KEY_COMMA           = 44,       // Key: ,
   KEY_MINUS           = 45,       // Key: -
   KEY_PERIOD          = 46,       // Key: .
   KEY_SLASH           = 47,       // Key: /
   KEY_ZERO            = 48,       // Key: 0
   KEY_ONE             = 49,       // Key: 1
   KEY_TWO             = 50,       // Key: 2
   KEY_THREE           = 51,       // Key: 3
   KEY_FOUR            = 52,       // Key: 4
   KEY_FIVE            = 53,       // Key: 5
   KEY_SIX             = 54,       // Key: 6
   KEY_SEVEN           = 55,       // Key: 7
   KEY_EIGHT           = 56,       // Key: 8
   KEY_NINE            = 57,       // Key: 9
   KEY_SEMICOLON       = 59,       // Key: ;
   KEY_EQUAL           = 61,       // Key: =
   KEY_A               = 65,       // Key: A | a
   KEY_B               = 66,       // Key: B | b
   KEY_C               = 67,       // Key: C | c
   KEY_D               = 68,       // Key: D | d
   KEY_E               = 69,       // Key: E | e
   KEY_F               = 70,       // Key: F | f
   KEY_G               = 71,       // Key: G | g
   KEY_H               = 72,       // Key: H | h
   KEY_I               = 73,       // Key: I | i
   KEY_J               = 74,       // Key: J | j
   KEY_K               = 75,       // Key: K | k
   KEY_L               = 76,       // Key: L | l
   KEY_M               = 77,       // Key: M | m
   KEY_N               = 78,       // Key: N | n
   KEY_O               = 79,       // Key: O | o
   KEY_P               = 80,       // Key: P | p
   KEY_Q               = 81,       // Key: Q | q
   KEY_R               = 82,       // Key: R | r
   KEY_S               = 83,       // Key: S | s
   KEY_T               = 84,       // Key: T | t
   KEY_U               = 85,       // Key: U | u
   KEY_V               = 86,       // Key: V | v
   KEY_W               = 87,       // Key: W | w
   KEY_X               = 88,       // Key: X | x
   KEY_Y               = 89,       // Key: Y | y
   KEY_Z               = 90,       // Key: Z | z
   KEY_LEFT_BRACKET    = 91,       // Key: [
   KEY_BACKSLASH       = 92,       // Key: '\'
   KEY_RIGHT_BRACKET   = 93,       // Key: ]
   KEY_GRAVE           = 96,       // Key: `
   // Function keys
   KEY_SPACE           = 32,       // Key: Space
   KEY_ESCAPE          = 256,      // Key: Esc
   KEY_ENTER           = 257,      // Key: Enter
   KEY_TAB             = 258,      // Key: Tab
   KEY_BACKSPACE       = 259,      // Key: Backspace
   KEY_INSERT          = 260,      // Key: Ins
   KEY_DELETE          = 261,      // Key: Del
   KEY_RIGHT           = 262,      // Key: Cursor right
   KEY_LEFT            = 263,      // Key: Cursor left
   KEY_DOWN            = 264,      // Key: Cursor down
   KEY_UP              = 265,      // Key: Cursor up
   KEY_PAGE_UP         = 266,      // Key: Page up
   KEY_PAGE_DOWN       = 267,      // Key: Page down
   KEY_HOME            = 268,      // Key: Home
   KEY_END             = 269,      // Key: End
   KEY_CAPS_LOCK       = 280,      // Key: Caps lock
   KEY_SCROLL_LOCK     = 281,      // Key: Scroll down
   KEY_NUM_LOCK        = 282,      // Key: Num lock
   KEY_PRINT_SCREEN    = 283,      // Key: Print screen
   KEY_PAUSE           = 284,      // Key: Pause
   KEY_F1              = 290,      // Key: F1
   KEY_F2              = 291,      // Key: F2
   KEY_F3              = 292,      // Key: F3
   KEY_F4              = 293,      // Key: F4
   KEY_F5              = 294,      // Key: F5
   KEY_F6              = 295,      // Key: F6
   KEY_F7              = 296,      // Key: F7
   KEY_F8              = 297,      // Key: F8
   KEY_F9              = 298,      // Key: F9
   KEY_F10             = 299,      // Key: F10
   KEY_F11             = 300,      // Key: F11
   KEY_F12             = 301,      // Key: F12
   KEY_LEFT_SHIFT      = 340,      // Key: Shift left
   KEY_LEFT_CONTROL    = 341,      // Key: Control left
   KEY_LEFT_ALT        = 342,      // Key: Alt left
   KEY_LEFT_SUPER      = 343,      // Key: Super left
   KEY_RIGHT_SHIFT     = 344,      // Key: Shift right
   KEY_RIGHT_CONTROL   = 345,      // Key: Control right
   KEY_RIGHT_ALT       = 346,      // Key: Alt right
   KEY_RIGHT_SUPER     = 347,      // Key: Super right
   KEY_KB_MENU         = 348,      // Key: KB menu
   // Keypad keys
   KEY_KP_0            = 320,      // Key: Keypad 0
   KEY_KP_1            = 321,      // Key: Keypad 1
   KEY_KP_2            = 322,      // Key: Keypad 2
   KEY_KP_3            = 323,      // Key: Keypad 3
   KEY_KP_4            = 324,      // Key: Keypad 4
   KEY_KP_5            = 325,      // Key: Keypad 5
   KEY_KP_6            = 326,      // Key: Keypad 6
   KEY_KP_7            = 327,      // Key: Keypad 7
   KEY_KP_8            = 328,      // Key: Keypad 8
   KEY_KP_9            = 329,      // Key: Keypad 9
   KEY_KP_DECIMAL      = 330,      // Key: Keypad .
   KEY_KP_DIVIDE       = 331,      // Key: Keypad /
   KEY_KP_MULTIPLY     = 332,      // Key: &Keypad 
   KEY_KP_SUBTRACT     = 333,      // Key: Keypad -
   KEY_KP_ADD          = 334,      // Key: Keypad +
   KEY_KP_ENTER        = 335,      // Key: Keypad Enter
   KEY_KP_EQUAL        = 336,      // Key: Keypad =
   // Android key buttons
   KEY_BACK            = 4,        // Key: Android back button
   KEY_MENU            = 5,        // Key: Android menu button
   KEY_VOLUME_UP       = 24,       // Key: Android volume up button
   KEY_VOLUME_DOWN     = 25        // Key: Android volume down button
}

// Mouse buttons
enum MouseButton : u32 {
   MOUSE_BUTTON_LEFT    = 0,       // Mouse button left
   MOUSE_BUTTON_RIGHT   = 1,       // Mouse button right
   MOUSE_BUTTON_MIDDLE  = 2,       // Mouse button middle (wheel: pressed)
   MOUSE_BUTTON_SIDE    = 3,       // Mouse button side (advanced mouse device)
   MOUSE_BUTTON_EXTRA   = 4,       // Mouse button extra (advanced mouse device)
   MOUSE_BUTTON_FORWARD = 5,       // Mouse button forward (advanced mouse device)
   MOUSE_BUTTON_BACK    = 6,       // Mouse button back (advanced mouse device)
}

// Mouse cursor
enum MouseCursor : u32 {
   MOUSE_CURSOR_DEFAULT       = 0,     // Default pointer shape
   MOUSE_CURSOR_ARROW         = 1,     // Arrow shape
   MOUSE_CURSOR_IBEAM         = 2,     // Text writing cursor shape
   MOUSE_CURSOR_CROSSHAIR     = 3,     // Cross shape
   MOUSE_CURSOR_POINTING_HAND = 4,     // Pointing hand cursor
   MOUSE_CURSOR_RESIZE_EW     = 5,     // Horizontal resize/move arrow shape
   MOUSE_CURSOR_RESIZE_NS     = 6,     // Vertical resize/move arrow shape
   MOUSE_CURSOR_RESIZE_NWSE   = 7,     // Top-left to bottom-right diagonal resize/move arrow shape
   MOUSE_CURSOR_RESIZE_NESW   = 8,     // The top-right to bottom-left diagonal resize/move arrow shape
   MOUSE_CURSOR_RESIZE_ALL    = 9,     // The omnidirectional resize/move cursor shape
   MOUSE_CURSOR_NOT_ALLOWED   = 10     // The operation-not-allowed shape
}

// Gamepad buttons
enum GamepadButton : u32 {
   GAMEPAD_BUTTON_UNKNOWN = 0,         // Unknown button, just for error checking
   GAMEPAD_BUTTON_LEFT_FACE_UP,        // Gamepad left DPAD up button
   GAMEPAD_BUTTON_LEFT_FACE_RIGHT,     // Gamepad left DPAD right button
   GAMEPAD_BUTTON_LEFT_FACE_DOWN,      // Gamepad left DPAD down button
   GAMEPAD_BUTTON_LEFT_FACE_LEFT,      // Gamepad left DPAD left button
   GAMEPAD_BUTTON_RIGHT_FACE_UP,       // Gamepad right button up (i.e. PS3: Triangle, Xbox: Y)
   GAMEPAD_BUTTON_RIGHT_FACE_RIGHT,    // Gamepad right button right (i.e. PS3: Circle, Xbox: B)
   GAMEPAD_BUTTON_RIGHT_FACE_DOWN,     // Gamepad right button down (i.e. PS3: Cross, Xbox: A)
   GAMEPAD_BUTTON_RIGHT_FACE_LEFT,     // Gamepad right button left (i.e. PS3: Square, Xbox: X)
   GAMEPAD_BUTTON_LEFT_TRIGGER_1,      // Gamepad top/back trigger left (first), it could be a trailing button
   GAMEPAD_BUTTON_LEFT_TRIGGER_2,      // Gamepad top/back trigger left (second), it could be a trailing button
   GAMEPAD_BUTTON_RIGHT_TRIGGER_1,     // Gamepad top/back trigger right (first), it could be a trailing button
   GAMEPAD_BUTTON_RIGHT_TRIGGER_2,     // Gamepad top/back trigger right (second), it could be a trailing button
   GAMEPAD_BUTTON_MIDDLE_LEFT,         // Gamepad center buttons, left one (i.e. PS3: Select)
   GAMEPAD_BUTTON_MIDDLE,              // Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX)
   GAMEPAD_BUTTON_MIDDLE_RIGHT,        // Gamepad center buttons, right one (i.e. PS3: Start)
   GAMEPAD_BUTTON_LEFT_THUMB,          // Gamepad joystick pressed button left
   GAMEPAD_BUTTON_RIGHT_THUMB          // Gamepad joystick pressed button right
}

// Gamepad axis
enum GamepadAxis : u32 {
   GAMEPAD_AXIS_LEFT_X        = 0,     // Gamepad left stick X axis
   GAMEPAD_AXIS_LEFT_Y        = 1,     // Gamepad left stick Y axis
   GAMEPAD_AXIS_RIGHT_X       = 2,     // Gamepad right stick X axis
   GAMEPAD_AXIS_RIGHT_Y       = 3,     // Gamepad right stick Y axis
   GAMEPAD_AXIS_LEFT_TRIGGER  = 4,     // Gamepad back trigger left, pressure level: [1..-1]
   GAMEPAD_AXIS_RIGHT_TRIGGER = 5      // Gamepad back trigger right, pressure level: [1..-1]
}

// Material map index
enum MaterialMapIndex : u32 {
   MATERIAL_MAP_ALBEDO = 0,        // Albedo material (same as: MATERIAL_MAP_DIFFUSE)
   MATERIAL_MAP_METALNESS,         // Metalness material (same as: MATERIAL_MAP_SPECULAR)
   MATERIAL_MAP_NORMAL,            // Normal material
   MATERIAL_MAP_ROUGHNESS,         // Roughness material
   MATERIAL_MAP_OCCLUSION,         // Ambient occlusion material
   MATERIAL_MAP_EMISSION,          // Emission material
   MATERIAL_MAP_HEIGHT,            // Heightmap material
   MATERIAL_MAP_CUBEMAP,           // Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
   MATERIAL_MAP_IRRADIANCE,        // Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
   MATERIAL_MAP_PREFILTER,         // Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
   MATERIAL_MAP_BRDF               // Brdf material
}

const MATERIAL_MAP_DIFFUSE: MaterialMapIndex = MaterialMapIndex::MATERIAL_MAP_ALBEDO;
const MATERIAL_MAP_SPECULAR: MaterialMapIndex = MaterialMapIndex::MATERIAL_MAP_METALNESS;

// Shader location index
enum ShaderLocationIndex : u32 {
   SHADER_LOC_VERTEX_POSITION = 0, // Shader location: vertex attribute: position
   SHADER_LOC_VERTEX_TEXCOORD01,   // Shader location: vertex attribute: texcoord01
   SHADER_LOC_VERTEX_TEXCOORD02,   // Shader location: vertex attribute: texcoord02
   SHADER_LOC_VERTEX_NORMAL,       // Shader location: vertex attribute: normal
   SHADER_LOC_VERTEX_TANGENT,      // Shader location: vertex attribute: tangent
   SHADER_LOC_VERTEX_COLOR,        // Shader location: vertex attribute: color
   SHADER_LOC_MATRIX_MVP,          // Shader location: matrix uniform: model-view-projection
   SHADER_LOC_MATRIX_VIEW,         // Shader location: matrix uniform: view (transform: camera)
   SHADER_LOC_MATRIX_PROJECTION,   // Shader location: matrix uniform: projection
   SHADER_LOC_MATRIX_MODEL,        // Shader location: matrix uniform: model (transform)
   SHADER_LOC_MATRIX_NORMAL,       // Shader location: matrix uniform: normal
   SHADER_LOC_VECTOR_VIEW,         // Shader location: vector uniform: view
   SHADER_LOC_COLOR_DIFFUSE,       // Shader location: vector uniform: diffuse color
   SHADER_LOC_COLOR_SPECULAR,      // Shader location: vector uniform: specular color
   SHADER_LOC_COLOR_AMBIENT,       // Shader location: vector uniform: ambient color
   SHADER_LOC_MAP_ALBEDO,          // Shader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE)
   SHADER_LOC_MAP_METALNESS,       // Shader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR)
   SHADER_LOC_MAP_NORMAL,          // Shader location: sampler2d texture: normal
   SHADER_LOC_MAP_ROUGHNESS,       // Shader location: sampler2d texture: roughness
   SHADER_LOC_MAP_OCCLUSION,       // Shader location: sampler2d texture: occlusion
   SHADER_LOC_MAP_EMISSION,        // Shader location: sampler2d texture: emission
   SHADER_LOC_MAP_HEIGHT,          // Shader location: sampler2d texture: height
   SHADER_LOC_MAP_CUBEMAP,         // Shader location: samplerCube texture: cubemap
   SHADER_LOC_MAP_IRRADIANCE,      // Shader location: samplerCube texture: irradiance
   SHADER_LOC_MAP_PREFILTER,       // Shader location: samplerCube texture: prefilter
   SHADER_LOC_MAP_BRDF,            // Shader location: sampler2d texture: brdf
   SHADER_LOC_VERTEX_BONEIDS,      // Shader location: vertex attribute: boneIds
   SHADER_LOC_VERTEX_BONEWEIGHTS,  // Shader location: vertex attribute: boneWeights
   SHADER_LOC_BONE_MATRICES        // Shader location: array of matrices uniform: boneMatrices
}

const SHADER_LOC_MAP_DIFFUSE: ShaderLocationIndex = ShaderLocationIndex::SHADER_LOC_MAP_ALBEDO;
const SHADER_LOC_MAP_SPECULAR: ShaderLocationIndex = ShaderLocationIndex::SHADER_LOC_MAP_METALNESS;

// Shader uniform data type
enum ShaderUniformDataType : u32 {
   SHADER_UNIFORM_FLOAT = 0,       // Shader uniform type: f32
   SHADER_UNIFORM_VEC2,            // Shader uniform type: vec2 (f32: 2)
   SHADER_UNIFORM_VEC3,            // Shader uniform type: vec3 (f32: 3)
   SHADER_UNIFORM_VEC4,            // Shader uniform type: vec4 (f32: 4)
   SHADER_UNIFORM_INT,             // Shader uniform type: i32
   SHADER_UNIFORM_IVEC2,           // Shader uniform type: ivec2 (i32: 2)
   SHADER_UNIFORM_IVEC3,           // Shader uniform type: ivec3 (i32: 3)
   SHADER_UNIFORM_IVEC4,           // Shader uniform type: ivec4 (i32: 4)
   SHADER_UNIFORM_SAMPLER2D        // Shader uniform type: sampler2d
}

// Shader attribute data types
enum ShaderAttributeDataType : u32 {
   SHADER_ATTRIB_FLOAT = 0,        // Shader attribute type: f32
   SHADER_ATTRIB_VEC2,             // Shader attribute type: vec2 (f32: 2)
   SHADER_ATTRIB_VEC3,             // Shader attribute type: vec3 (f32: 3)
   SHADER_ATTRIB_VEC4              // Shader attribute type: vec4 (f32: 4)
}

// Pixel formats
// NOTE: Support depends on OpenGL version and platform
enum PixelFormat : u32 {
   PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1, // 8 bit per pixel (alpha: no)
   PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA,    // 8*2 bpp (channels: 2)
   PIXELFORMAT_UNCOMPRESSED_R5G6B5,        // 16 bpp
   PIXELFORMAT_UNCOMPRESSED_R8G8B8,        // 24 bpp
   PIXELFORMAT_UNCOMPRESSED_R5G5B5A1,      // 16 bpp (1 bit alpha)
   PIXELFORMAT_UNCOMPRESSED_R4G4B4A4,      // 16 bpp (4 bit alpha)
   PIXELFORMAT_UNCOMPRESSED_R8G8B8A8,      // 32 bpp
   PIXELFORMAT_UNCOMPRESSED_R32,           // 32 bpp (1 channel - f32)
   PIXELFORMAT_UNCOMPRESSED_R32G32B32,     // 32*3 bpp (3 channels - f32)
   PIXELFORMAT_UNCOMPRESSED_R32G32B32A32,  // 32*4 bpp (4 channels - f32)
   PIXELFORMAT_UNCOMPRESSED_R16,           // 16 bpp (1 channel - half f32)
   PIXELFORMAT_UNCOMPRESSED_R16G16B16,     // 16*3 bpp (3 channels - half f32)
   PIXELFORMAT_UNCOMPRESSED_R16G16B16A16,  // 16*4 bpp (4 channels - half f32)
   PIXELFORMAT_COMPRESSED_DXT1_RGB,        // 4 bpp (alpha: no)
   PIXELFORMAT_COMPRESSED_DXT1_RGBA,       // 4 bpp (1 bit alpha)
   PIXELFORMAT_COMPRESSED_DXT3_RGBA,       // 8 bpp
   PIXELFORMAT_COMPRESSED_DXT5_RGBA,       // 8 bpp
   PIXELFORMAT_COMPRESSED_ETC1_RGB,        // 4 bpp
   PIXELFORMAT_COMPRESSED_ETC2_RGB,        // 4 bpp
   PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA,   // 8 bpp
   PIXELFORMAT_COMPRESSED_PVRT_RGB,        // 4 bpp
   PIXELFORMAT_COMPRESSED_PVRT_RGBA,       // 4 bpp
   PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA,   // 8 bpp
   PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA    // 2 bpp
}

// Texture parameters: filter mode
// NOTE 1: Filtering considers mipmaps if available in the texture
// NOTE 2: Filter is accordingly set for minification and magnification
enum TextureFilter : u32 {
   TEXTURE_FILTER_POINT = 0,               // No filter, just pixel approximation
   TEXTURE_FILTER_BILINEAR,                // Linear filtering
   TEXTURE_FILTER_TRILINEAR,               // Trilinear filtering (linear with mipmaps)
   TEXTURE_FILTER_ANISOTROPIC_4X,          // Anisotropic filtering 4x
   TEXTURE_FILTER_ANISOTROPIC_8X,          // Anisotropic filtering 8x
   TEXTURE_FILTER_ANISOTROPIC_16X,         // Anisotropic filtering 16x
}

// Texture parameters: wrap mode
enum TextureWrap : u32 {
   TEXTURE_WRAP_REPEAT = 0,                // Repeats texture in tiled mode
   TEXTURE_WRAP_CLAMP,                     // Clamps texture to edge pixel in tiled mode
   TEXTURE_WRAP_MIRROR_REPEAT,             // Mirrors and repeats the texture in tiled mode
   TEXTURE_WRAP_MIRROR_CLAMP               // Mirrors and clamps to border the texture in tiled mode
}

// Cubemap layouts
enum CubemapLayout : u32 {
   CUBEMAP_LAYOUT_AUTO_DETECT = 0,         // Automatically detect layout type
   CUBEMAP_LAYOUT_LINE_VERTICAL,           // Layout is defined by a vertical line with faces
   CUBEMAP_LAYOUT_LINE_HORIZONTAL,         // Layout is defined by a horizontal line with faces
   CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR,     // Layout is defined by a 3x4 cross with cubemap faces
   CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE     // Layout is defined by a 4x3 cross with cubemap faces
}

// Font type, defines generation method
enum FontType : u32 {
   FONT_DEFAULT = 0,               // Default font generation, anti-aliased
   FONT_BITMAP,                    // Bitmap font generation, no anti-aliasing
   FONT_SDF                        // SDF font generation, requires external shader
}

// Color blending modes (pre-defined)
enum BlendMode : u32 {
   BLEND_ALPHA = 0,                // Blend textures considering alpha (default)
   BLEND_ADDITIVE,                 // Blend textures adding colors
   BLEND_MULTIPLIED,               // Blend textures multiplying colors
   BLEND_ADD_COLORS,               // Blend textures adding colors (alternative)
   BLEND_SUBTRACT_COLORS,          // Blend textures subtracting colors (alternative)
   BLEND_ALPHA_PREMULTIPLY,        // Blend premultiplied textures considering alpha
   BLEND_CUSTOM,                   // Blend textures using custom src/dst factors (use rlSetBlendFactors())
   BLEND_CUSTOM_SEPARATE           // Blend textures using custom rgb/alpha separate src/dst factors (use rlSetBlendFactorsSeparate())
}

// Gesture
// NOTE: Provided as bit-wise flags to enable only desired gestures
enum Gesture : u32 {
   GESTURE_NONE        = 0,        // No gesture
   GESTURE_TAP         = 1,        // Tap gesture
   GESTURE_DOUBLETAP   = 2,        // Double tap gesture
   GESTURE_HOLD        = 4,        // Hold gesture
   GESTURE_DRAG        = 8,        // Drag gesture
   GESTURE_SWIPE_RIGHT = 16,       // Swipe right gesture
   GESTURE_SWIPE_LEFT  = 32,       // Swipe left gesture
   GESTURE_SWIPE_UP    = 64,       // Swipe up gesture
   GESTURE_SWIPE_DOWN  = 128,      // Swipe down gesture
   GESTURE_PINCH_IN    = 256,      // Pinch in gesture
   GESTURE_PINCH_OUT   = 512       // Pinch out gesture
}

// Camera system modes
enum CameraMode : u32 {
   CAMERA_CUSTOM = 0,              // Camera custom, controlled by user (UpdateCamera() does nothing)
   CAMERA_FREE,                    // Camera free mode
   CAMERA_ORBITAL,                 // Camera orbital, target: around, zoom supported
   CAMERA_FIRST_PERSON,            // Camera first person
   CAMERA_THIRD_PERSON             // Camera third person
}

// Camera projection
enum CameraProjection : u32 {
   CAMERA_PERSPECTIVE = 0,         // Perspective projection
   CAMERA_ORTHOGRAPHIC             // Orthographic projection
}

// N-patch layout
enum NPatchLayout : u32 {
   NPATCH_NINE_PATCH = 0,          // Npatch layout: 3x3 tiles
   NPATCH_THREE_PATCH_VERTICAL,    // Npatch layout: 1x3 tiles
   NPATCH_THREE_PATCH_HORIZONTAL   // Npatch layout: 3x1 tiles
}

// Callbacks to hook some internal functions
// WARNING: These callbacks are intended for advanced users
//type TraceLogCallback = proc(i32, &i8, va_list);  // Logging: Redirect trace log messages
type LoadFileDataCallback = proc(&i8, &i32) -> &u8;    // FileIO: Load binary data
type SaveFileDataCallback = proc(&i8, &unit, i32) -> bool;   // FileIO: Save binary data
type LoadFileTextCallback = proc(&i8) -> &i8;            // FileIO: Load text data
type SaveFileTextCallback = proc(&i8, &i8) -> bool; // FileIO: Save text data

//------------------------------------------------------------------------------------
// Global Variables Definition
//------------------------------------------------------------------------------------
// It's lonely here...

//------------------------------------------------------------------------------------
// Window and Graphics Device Functions (Module: core)
//------------------------------------------------------------------------------------

// Window-related functions
extern proc InitWindow(width: i32, height: i32, title: &i8); // Initialize window and OpenGL context
extern proc CloseWindow(); // Close window and unload OpenGL context
extern proc WindowShouldClose() -> bool; // Check if application should close (KEY_ESCAPE pressed or windows close icon clicked)
extern proc IsWindowReady() -> bool; // Check if window has been initialized successfully
extern proc IsWindowFullscreen() -> bool; // Check if window is currently fullscreen
extern proc IsWindowHidden() -> bool; // Check if window is currently hidden
extern proc IsWindowMinimized() -> bool; // Check if window is currently minimized
extern proc IsWindowMaximized() -> bool; // Check if window is currently maximized
extern proc IsWindowFocused() -> bool; // Check if window is currently focused
extern proc IsWindowResized() -> bool; // Check if window has been resized last frame
extern proc IsWindowState(flag: u32) -> bool; // Check if one specific window flag is enabled
extern proc SetWindowState(flags: u32); // Set window configuration state using flags
extern proc ClearWindowState(flags: u32); // Clear window configuration state flags
extern proc ToggleFullscreen(); // Toggle window state: fullscreen/windowed, resizes monitor to match window resolution
extern proc ToggleBorderlessWindowed(); // Toggle window state: borderless windowed, resizes window to match monitor resolution
extern proc MaximizeWindow(); // Set window state: maximized, if resizable
extern proc MinimizeWindow(); // Set window state: minimized, if resizable
extern proc RestoreWindow(); // Set window state: not minimized/maximized
extern proc SetWindowIcon(image: Image); // Set icon for window (image: single, RGBA 32bit)
extern proc SetWindowIcons(images: &Image, count: i32); // Set icon for window (images: multiple, RGBA 32bit)
extern proc SetWindowTitle(title: &i8); // Set title for window
extern proc SetWindowPosition(x: i32, y: i32); // Set window position on screen
extern proc SetWindowMonitor(monitor: i32); // Set monitor for the current window
extern proc SetWindowMinSize(width: i32, height: i32); // Set window minimum dimensions (FLAG_WINDOW_RESIZABLE: for)
extern proc SetWindowMaxSize(width: i32, height: i32); // Set window maximum dimensions (FLAG_WINDOW_RESIZABLE: for)
extern proc SetWindowSize(width: i32, height: i32); // Set window dimensions
extern proc SetWindowOpacity(opacity: f32); // Set window opacity [0.0f..1.0f]
extern proc SetWindowFocused(); // Set window focused
extern proc GetWindowHandle() -> &unit;                                // Get native window handle
extern proc GetScreenWidth() -> i32; // Get current screen width
extern proc GetScreenHeight() -> i32; // Get current screen height
extern proc GetRenderWidth() -> i32; // Get current render width (it considers HiDPI)
extern proc GetRenderHeight() -> i32; // Get current render height (it considers HiDPI)
extern proc GetMonitorCount() -> i32; // Get number of connected monitors
extern proc GetCurrentMonitor() -> i32; // Get current monitor where window is placed
extern proc GetMonitorPosition(monitor: i32) -> Vector2; // Get specified monitor position
extern proc GetMonitorWidth(monitor: i32) -> i32; // Get specified monitor width (current video mode used by monitor)
extern proc GetMonitorHeight(monitor: i32) -> i32; // Get specified monitor height (current video mode used by monitor)
extern proc GetMonitorPhysicalWidth(monitor: i32) -> i32; // Get specified monitor physical width in millimetres
extern proc GetMonitorPhysicalHeight(monitor: i32) -> i32; // Get specified monitor physical height in millimetres
extern proc GetMonitorRefreshRate(monitor: i32) -> i32; // Get specified monitor refresh rate
extern proc GetWindowPosition() -> Vector2; // Get window position XY on monitor
extern proc GetWindowScaleDPI() -> Vector2; // Get window scale DPI factor
extern proc GetMonitorName(monitor: i32) -> &i8; // Get the human-readable, UTF-8 encoded name of the specified monitor
extern proc SetClipboardText(text: &i8); // Set clipboard text content
extern proc GetClipboardText() -> &i8; // Get clipboard text content
extern proc GetClipboardImage() -> Image; // Get clipboard image content
extern proc EnableEventWaiting(); // Enable waiting for events on EndDrawing(), no automatic event polling
extern proc DisableEventWaiting(); // Disable waiting for events on EndDrawing(), automatic events polling

// Cursor-related functions
extern proc ShowCursor(); // Shows cursor
extern proc HideCursor(); // Hides cursor
extern proc IsCursorHidden() -> bool; // Check if cursor is not visible
extern proc EnableCursor(); // Enables cursor (cursor: unlock)
extern proc DisableCursor(); // Disables cursor (cursor: lock)
extern proc IsCursorOnScreen() -> bool; // Check if cursor is on the screen

// Drawing-related functions
extern proc ClearBackground(color: Color); // Set background color (framebuffer clear color)
extern proc BeginDrawing(); // Setup canvas (framebuffer) to start drawing
extern proc EndDrawing(); // End canvas drawing and swap buffers (buffering: double)
extern proc BeginMode2D(camera: Camera2D); // Begin 2D mode with custom camera (2D)
extern proc EndMode2D(); // Ends 2D mode with custom camera
extern proc BeginMode3D(camera: Camera3D); // Begin 3D mode with custom camera (3D)
extern proc EndMode3D(); // Ends 3D mode and returns to default 2D orthographic mode
extern proc BeginTextureMode(target: RenderTexture2D); // Begin drawing to render texture
extern proc EndTextureMode(); // Ends drawing to render texture
extern proc BeginShaderMode(shader: Shader); // Begin custom shader drawing
extern proc EndShaderMode(); // End custom shader drawing (use default shader)
extern proc BeginBlendMode(mode: i32); // Begin blending mode (additive: alpha,, subtract: multiplied,, custom)
extern proc EndBlendMode(); // End blending mode (reset to default: alpha blending)
extern proc BeginScissorMode(x: i32, y: i32, width: i32, height: i32); // Begin scissor mode (define screen area for following drawing)
extern proc EndScissorMode(); // End scissor mode
extern proc BeginVrStereoMode(config: VrStereoConfig); // Begin stereo rendering (requires VR simulator)
extern proc EndVrStereoMode(); // End stereo rendering (requires VR simulator)

// VR stereo config functions for VR simulator
extern proc LoadVrStereoConfig(device: VrDeviceInfo) -> VrStereoConfig; // Load VR stereo config for VR simulator device parameters
extern proc UnloadVrStereoConfig(config: VrStereoConfig); // Unload VR stereo config

// Shader management functions
// NOTE: Shader functionality is not available on OpenGL 1.1
extern proc LoadShader(vsFileName: &i8, fsFileName: &i8) -> Shader; // Load shader from files and bind default locations
extern proc LoadShaderFromMemory(vsCode: &i8, fsCode: &i8) -> Shader; // Load shader from code strings and bind default locations
extern proc IsShaderValid(shader: Shader) -> bool; // Check if a shader is valid (loaded on GPU)
extern proc GetShaderLocation(shader: Shader, uniformName: &i8) -> i32; // Get shader uniform location
extern proc GetShaderLocationAttrib(shader: Shader, attribName: &i8) -> i32; // Get shader attribute location
extern proc SetShaderValue(shader: Shader, locIndex: i32, value: &unit, uniformType: i32); // Set shader uniform value
extern proc SetShaderValueV(shader: Shader, locIndex: i32, value: &unit, uniformType: i32, count: i32); // Set shader uniform value vector
extern proc SetShaderValueMatrix(shader: Shader, locIndex: i32, mat: Matrix); // Set shader uniform value (matrix 4x4)
extern proc SetShaderValueTexture(shader: Shader, locIndex: i32, texture: Texture2D); // Set shader uniform value for texture (sampler2d)
extern proc UnloadShader(shader: Shader); // Unload shader from GPU memory (VRAM)

// Screen-space-related functions
extern proc GetScreenToWorldRay(position: Vector2, camera: Camera) -> Ray; // Get a ray trace from screen position (mouse: i.e)
extern proc GetScreenToWorldRayEx(position: Vector2, camera: Camera, width: i32, height: i32) -> Ray; // Get a ray trace from screen position (mouse: i.e) in a viewport
extern proc GetWorldToScreen(position: Vector3, camera: Camera) -> Vector2; // Get the screen space position for a 3d world space position
extern proc GetWorldToScreenEx(position: Vector3, camera: Camera, width: i32, height: i32) -> Vector2; // Get size position for a 3d world space position
extern proc GetWorldToScreen2D(position: Vector2, camera: Camera2D) -> Vector2; // Get the screen space position for a 2d camera world space position
extern proc GetScreenToWorld2D(position: Vector2, camera: Camera2D) -> Vector2; // Get the world space position for a 2d camera screen space position
extern proc GetCameraMatrix(camera: Camera) -> Matrix; // Get camera transform matrix (matrix: view)
extern proc GetCameraMatrix2D(camera: Camera2D) -> Matrix; // Get camera 2d transform matrix

// Timing-related functions
extern proc SetTargetFPS(fps: i32); // Set target FPS (maximum)
extern proc GetFrameTime() -> f32; // Get time in seconds for last frame drawn (time: delta)
extern proc GetTime() -> f64; // Get elapsed time in seconds since InitWindow()
extern proc GetFPS() -> i32; // Get current FPS

// Custom frame control functions
// NOTE: Those functions are intended for advanced users that want full control over the frame processing
// By default EndDrawing() does this job: draws everything + SwapScreenBuffer() + manage frame timing + PollInputEvents()
// To avoid that behaviour and control frame processes manually, enable in config.h: SUPPORT_CUSTOM_FRAME_CONTROL
extern proc SwapScreenBuffer(); // Swap back buffer with front buffer (drawing: screen)
extern proc PollInputEvents(); // Register all input events
extern proc WaitTime(seconds: f64); // Wait for some time (halt program execution)

// Random values generation functions
extern proc SetRandomSeed(seed: u32); // Set the seed for the random number generator
extern proc GetRandomValue(min: i32, max: i32) -> i32; // Get a random value between min and max (included: both)
extern proc LoadRandomSequence(count: u32, min: i32, max: i32) -> &i32; // Load random values sequence, no values repeated
extern proc UnloadRandomSequence(sequence: &i32); // Unload random values sequence

// Misc. functions
extern proc TakeScreenshot(fileName: &i8); // Takes a screenshot of current screen (filename extension defines format)
extern proc SetConfigFlags(flags: u32); // Setup init configuration flags (FLAGS: view)
extern proc OpenURL(url: &i8); // Open URL with default system browser (available: if)

// NOTE: Following functions implemented in module [utils]
//------------------------------------------------------------------
//extern proc TraceLog(logLevel: i32, text: &i8, ...); // Show trace log messages (LOG_INFO: LOG_DEBUG,, LOG_WARNING, LOG_ERROR...)
extern proc SetTraceLogLevel(logLevel: i32); // Set the current threshold (minimum) log level
extern proc MemAlloc(size: u32) -> &unit;                          // Internal memory allocator
extern proc MemRealloc(ptr: &unit, size: u32) -> &unit;             // Internal memory reallocator
extern proc MemFree(ptr: &unit); // Internal memory free

// Set custom callbacks
// WARNING: Callbacks setup is intended for advanced users
//extern proc SetTraceLogCallback(callback: TraceLogCallback); // Set custom trace log
extern proc SetLoadFileDataCallback(callback: LoadFileDataCallback); // Set custom file binary data loader
extern proc SetSaveFileDataCallback(callback: SaveFileDataCallback); // Set custom file binary data saver
extern proc SetLoadFileTextCallback(callback: LoadFileTextCallback); // Set custom file text data loader
extern proc SetSaveFileTextCallback(callback: SaveFileTextCallback); // Set custom file text data saver

// Files management functions
extern proc LoadFileData(fileName: &i8, dataSize: &i32) -> &u8; // Load file data as byte array (read)
extern proc UnloadFileData(data: &u8); // Unload file data allocated by LoadFileData()
extern proc SaveFileData(fileName: &i8, data: &unit, dataSize: i32) -> bool; // Save data to file from byte array (write), returns true on success
extern proc ExportDataAsCode(data: &u8, dataSize: i32, fileName: &i8) -> bool; // Export data to code (.h), returns true on success
extern proc LoadFileText(fileName: &i8) -> &i8; // Load text data from file (read), returns a '\0' terminated string
extern proc UnloadFileText(text: &i8); // Unload file text data allocated by LoadFileText()
extern proc SaveFileText(fileName: &i8, text: &i8) -> bool; // Save text data to file (write), string must be '\0' terminated, returns true on success
//------------------------------------------------------------------

// File system functions
extern proc FileExists(fileName: &i8) -> bool; // Check if file exists
extern proc DirectoryExists(dirPath: &i8) -> bool; // Check if a directory path exists
extern proc IsFileExtension(fileName: &i8, ext: &i8) -> bool; // Check file extension (including point: .png, .wav)
extern proc GetFileLength(fileName: &i8) -> i32; // Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)
extern proc GetFileExtension(fileName: &i8) -> &i8; // Get pointer to extension for a filename string (includes dot: '.png')
extern proc GetFileName(filePath: &i8) -> &i8; // Get pointer to filename for a path string
extern proc GetFileNameWithoutExt(filePath: &i8) -> &i8; // Get filename string without extension (uses static string)
extern proc GetDirectoryPath(filePath: &i8) -> &i8; // Get full path for a given fileName with path (uses static string)
extern proc GetPrevDirectoryPath(dirPath: &i8) -> &i8; // Get previous directory path for a given path (uses static string)
extern proc GetWorkingDirectory() -> &i8; // Get current working directory (uses static string)
extern proc GetApplicationDirectory() -> &i8; // Get the directory of the running application (uses static string)
extern proc MakeDirectory(dirPath: &i8) -> i32; // Create directories (including full path requested), returns 0 on success
extern proc ChangeDirectory(dir: &i8) -> bool; // Change working directory, return true on success
extern proc IsPathFile(path: &i8) -> bool; // Check if a given path is a file or a directory
extern proc IsFileNameValid(fileName: &i8) -> bool; // Check if fileName is valid for the platform/OS
extern proc LoadDirectoryFiles(dirPath: &i8) -> FilePathList; // Load directory filepaths
extern proc LoadDirectoryFilesEx(basePath: &i8, filter: &i8, scanSubdirs: bool) -> FilePathList; // Load directory filepaths with extension filtering and recursive directory scan. Use 'DIR' in the filter string to include directories in the result
extern proc UnloadDirectoryFiles(files: FilePathList); // Unload filepaths
extern proc IsFileDropped() -> bool; // Check if a file has been dropped into window
extern proc LoadDroppedFiles() -> FilePathList; // Load dropped filepaths
extern proc UnloadDroppedFiles(files: FilePathList); // Unload dropped filepaths
// rjm: hardcoding return type to i64, but this would be wrong for windows. @CLong
extern proc GetFileModTime(fileName: &i8) -> i64; // Get file modification time (last write time)

// Compression/Encoding functionality
extern proc CompressData(data: &u8, dataSize: i32, compDataSize: &i32) -> &u8; // Compress data (algorithm: DEFLATE), memory must be MemFree()
extern proc DecompressData(compData: &u8, compDataSize: i32, dataSize: &i32) -> &u8; // Decompress data (algorithm: DEFLATE), memory must be MemFree()
extern proc EncodeDataBase64(data: &u8, dataSize: i32, outputSize: &i32) -> &i8; // Encode data to Base64 string, memory must be MemFree()
extern proc DecodeDataBase64(data: &u8, outputSize: &i32) -> &u8; // Decode Base64 string data, memory must be MemFree()
extern proc ComputeCRC32(data: &u8, dataSize: i32) -> u32; // Compute CRC32 hash code
extern proc ComputeMD5(data: &u8, dataSize: i32) -> &u32; // Compute MD5 hash code, returns static i32[4] (bytes: 16)
extern proc ComputeSHA1(data: &u8, dataSize: i32) -> &u32; // Compute SHA1 hash code, returns static i32[5] (bytes: 20)


// Automation events functionality
extern proc LoadAutomationEventList(fileName: &i8) -> AutomationEventList; // Load automation events list from file, NULL for empty list, capacity = MAX_AUTOMATION_EVENTS
extern proc UnloadAutomationEventList(list: AutomationEventList); // Unload automation events list from file
extern proc ExportAutomationEventList(list: AutomationEventList, fileName: &i8) -> bool; // Export automation events list as text file
extern proc SetAutomationEventList(list: &AutomationEventList); // Set automation event list to record to
extern proc SetAutomationEventBaseFrame(frame: i32); // Set automation event internal base frame to start recording
extern proc StartAutomationEventRecording(); // Start recording automation events (AutomationEventList must be set)
extern proc StopAutomationEventRecording(); // Stop recording automation events
extern proc PlayAutomationEvent(event: AutomationEvent); // Play a recorded automation event

//------------------------------------------------------------------------------------
// Input Handling Functions (Module: core)
//------------------------------------------------------------------------------------

// Input-related functions: keyboard
extern proc IsKeyPressed(key: i32) -> bool; // Check if a key has been pressed once
extern proc IsKeyPressedRepeat(key: i32) -> bool; // Check if a key has been pressed again
extern proc IsKeyDown(key: i32) -> bool; // Check if a key is being pressed
extern proc IsKeyReleased(key: i32) -> bool; // Check if a key has been released once
extern proc IsKeyUp(key: i32) -> bool; // Check if a key is NOT being pressed
extern proc GetKeyPressed() -> i32; // Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty
extern proc GetCharPressed() -> i32; // Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty
extern proc SetExitKey(key: i32); // Set a custom key to exit program (default is ESC)

// Input-related functions: gamepads
extern proc IsGamepadAvailable(gamepad: i32) -> bool; // Check if a gamepad is available
extern proc GetGamepadName(gamepad: i32) -> &i8; // Get gamepad internal name id
extern proc IsGamepadButtonPressed(gamepad: i32, button: i32) -> bool; // Check if a gamepad button has been pressed once
extern proc IsGamepadButtonDown(gamepad: i32, button: i32) -> bool; // Check if a gamepad button is being pressed
extern proc IsGamepadButtonReleased(gamepad: i32, button: i32) -> bool; // Check if a gamepad button has been released once
extern proc IsGamepadButtonUp(gamepad: i32, button: i32) -> bool; // Check if a gamepad button is NOT being pressed
extern proc GetGamepadButtonPressed() -> i32; // Get the last gamepad button pressed
extern proc GetGamepadAxisCount(gamepad: i32) -> i32; // Get gamepad axis count for a gamepad
extern proc GetGamepadAxisMovement(gamepad: i32, axis: i32) -> f32; // Get axis movement value for a gamepad axis
extern proc SetGamepadMappings(mappings: &i8) -> i32; // Set internal gamepad mappings (SDL_GameControllerDB)
extern proc SetGamepadVibration(gamepad: i32, leftMotor: f32, rightMotor: f32, duration: f32); // Set gamepad vibration for both motors (duration in seconds)

// Input-related functions: mouse
extern proc IsMouseButtonPressed(button: i32) -> bool; // Check if a mouse button has been pressed once
extern proc IsMouseButtonDown(button: i32) -> bool; // Check if a mouse button is being pressed
extern proc IsMouseButtonReleased(button: i32) -> bool; // Check if a mouse button has been released once
extern proc IsMouseButtonUp(button: i32) -> bool; // Check if a mouse button is NOT being pressed
extern proc GetMouseX() -> i32; // Get mouse position X
extern proc GetMouseY() -> i32; // Get mouse position Y
extern proc GetMousePosition() -> Vector2; // Get mouse position XY
extern proc GetMouseDelta() -> Vector2; // Get mouse delta between frames
extern proc SetMousePosition(x: i32, y: i32); // Set mouse position XY
extern proc SetMouseOffset(offsetX: i32, offsetY: i32); // Set mouse offset
extern proc SetMouseScale(scaleX: f32, scaleY: f32); // Set mouse scaling
extern proc GetMouseWheelMove() -> f32; // Get mouse wheel movement for X or Y, whichever is larger
extern proc GetMouseWheelMoveV() -> Vector2; // Get mouse wheel movement for both X and Y
extern proc SetMouseCursor(cursor: i32); // Set mouse cursor

// Input-related functions: touch
extern proc GetTouchX() -> i32; // Get touch position X for touch point 0 (relative to screen size)
extern proc GetTouchY() -> i32; // Get touch position Y for touch point 0 (relative to screen size)
extern proc GetTouchPosition(index: i32) -> Vector2; // Get touch position XY for a touch point index (relative to screen size)
extern proc GetTouchPointId(index: i32) -> i32; // Get touch point identifier for given index
extern proc GetTouchPointCount() -> i32; // Get number of touch points

//------------------------------------------------------------------------------------
// Gestures and Touch Handling Functions (Module: rgestures)
//------------------------------------------------------------------------------------
extern proc SetGesturesEnabled(flags: u32); // Enable a set of gestures using flags
extern proc IsGestureDetected(gesture: u32) -> bool; // Check if a gesture have been detected
extern proc GetGestureDetected() -> i32; // Get latest detected gesture
extern proc GetGestureHoldDuration() -> f32; // Get gesture hold time in seconds
extern proc GetGestureDragVector() -> Vector2; // Get gesture drag vector
extern proc GetGestureDragAngle() -> f32; // Get gesture drag angle
extern proc GetGesturePinchVector() -> Vector2; // Get gesture pinch delta
extern proc GetGesturePinchAngle() -> f32; // Get gesture pinch angle

//------------------------------------------------------------------------------------
// Camera System Functions (Module: rcamera)
//------------------------------------------------------------------------------------
extern proc UpdateCamera(camera: &Camera, mode: i32); // Update camera position for selected mode
extern proc UpdateCameraPro(camera: &Camera, movement: Vector3, rotation: Vector3, zoom: f32); // Update camera movement/rotation

//------------------------------------------------------------------------------------
// Basic Shapes Drawing Functions (Module: shapes)
//------------------------------------------------------------------------------------
// Set texture and rectangle to be used on shapes drawing
// NOTE: It can be useful when using basic shapes and one single font,
// defining a font char white rectangle would allow drawing everything in a single draw call
extern proc SetShapesTexture(texture: Texture2D, source: Rectangle); // Set texture and rectangle to be used on shapes drawing
extern proc GetShapesTexture() -> Texture2D; // Get texture that is used for shapes drawing
extern proc GetShapesTextureRectangle() -> Rectangle; // Get texture source rectangle that is used for shapes drawing

// Basic shapes drawing functions
extern proc DrawPixel(posX: i32, posY: i32, color: Color); // Draw a pixel using geometry [Can be slow, use with care]
extern proc DrawPixelV(position: Vector2, color: Color); // Draw a pixel using geometry (version: Vector) [Can be slow, use with care]
extern proc DrawLine(startPosX: i32, startPosY: i32, endPosX: i32, endPosY: i32, color: Color); // Draw a line
extern proc DrawLineV(startPos: Vector2, endPos: Vector2, color: Color); // Draw a line (using gl lines)
extern proc DrawLineEx(startPos: Vector2, endPos: Vector2, thick: f32, color: Color); // Draw a line (using triangles/quads)
extern proc DrawLineStrip(points: &Vector2, pointCount: i32, color: Color); // Draw lines sequence (using gl lines)
extern proc DrawLineBezier(startPos: Vector2, endPos: Vector2, thick: f32, color: Color); // Draw line segment cubic-bezier in-out interpolation
extern proc DrawCircle(centerX: i32, centerY: i32, radius: f32, color: Color); // Draw a color-filled circle
extern proc DrawCircleSector(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color); // Draw a piece of a circle
extern proc DrawCircleSectorLines(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color); // Draw circle sector outline
extern proc DrawCircleGradient(centerX: i32, centerY: i32, radius: f32, inner: Color, outer: Color); // Draw a gradient-filled circle
extern proc DrawCircleV(center: Vector2, radius: f32, color: Color); // Draw a color-filled circle (version: Vector)
extern proc DrawCircleLines(centerX: i32, centerY: i32, radius: f32, color: Color); // Draw circle outline
extern proc DrawCircleLinesV(center: Vector2, radius: f32, color: Color); // Draw circle outline (version: Vector)
extern proc DrawEllipse(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: Color); // Draw ellipse
extern proc DrawEllipseLines(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: Color); // Draw ellipse outline
extern proc DrawRing(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color); // Draw ring
extern proc DrawRingLines(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color); // Draw ring outline
extern proc DrawRectangle(posX: i32, posY: i32, width: i32, height: i32, color: Color); // Draw a color-filled rectangle
extern proc DrawRectangleV(position: Vector2, size: Vector2, color: Color); // Draw a color-filled rectangle (version: Vector)
extern proc DrawRectangleRec(rec: Rectangle, color: Color); // Draw a color-filled rectangle
extern proc DrawRectanglePro(rec: Rectangle, origin: Vector2, rotation: f32, color: Color); // Draw a color-filled rectangle with pro parameters
extern proc DrawRectangleGradientV(posX: i32, posY: i32, width: i32, height: i32, top: Color, bottom: Color); // Draw a vertical-gradient-filled rectangle
extern proc DrawRectangleGradientH(posX: i32, posY: i32, width: i32, height: i32, left: Color, right: Color); // Draw a horizontal-gradient-filled rectangle
extern proc DrawRectangleGradientEx(rec: Rectangle, topLeft: Color, bottomLeft: Color, topRight: Color, bottomRight: Color); // Draw a gradient-filled rectangle with custom vertex colors
extern proc DrawRectangleLines(posX: i32, posY: i32, width: i32, height: i32, color: Color); // Draw rectangle outline
extern proc DrawRectangleLinesEx(rec: Rectangle, lineThick: f32, color: Color); // Draw rectangle outline with extended parameters
extern proc DrawRectangleRounded(rec: Rectangle, roundness: f32, segments: i32, color: Color); // Draw rectangle with rounded edges
extern proc DrawRectangleRoundedLines(rec: Rectangle, roundness: f32, segments: i32, color: Color); // Draw rectangle lines with rounded edges
extern proc DrawRectangleRoundedLinesEx(rec: Rectangle, roundness: f32, segments: i32, lineThick: f32, color: Color); // Draw rectangle with rounded edges outline
extern proc DrawTriangle(v1: Vector2, v2: Vector2, v3: Vector2, color: Color); // Draw a color-filled triangle (vertex in counter-clockwise order!)
extern proc DrawTriangleLines(v1: Vector2, v2: Vector2, v3: Vector2, color: Color); // Draw triangle outline (vertex in counter-clockwise order!)
extern proc DrawTriangleFan(points: &Vector2, pointCount: i32, color: Color); // Draw a triangle fan defined by points (first vertex is the center)
extern proc DrawTriangleStrip(points: &Vector2, pointCount: i32, color: Color); // Draw a triangle strip defined by points
extern proc DrawPoly(center: Vector2, sides: i32, radius: f32, rotation: f32, color: Color); // Draw a regular polygon (version: Vector)
extern proc DrawPolyLines(center: Vector2, sides: i32, radius: f32, rotation: f32, color: Color); // Draw a polygon outline of n sides
extern proc DrawPolyLinesEx(center: Vector2, sides: i32, radius: f32, rotation: f32, lineThick: f32, color: Color); // Draw a polygon outline of n sides with extended parameters

// Splines drawing functions
extern proc DrawSplineLinear(points: &Vector2, pointCount: i32, thick: f32, color: Color); // Draw spline: Linear, minimum 2 points
extern proc DrawSplineBasis(points: &Vector2, pointCount: i32, thick: f32, color: Color); // Draw spline: B-Spline, minimum 4 points
extern proc DrawSplineCatmullRom(points: &Vector2, pointCount: i32, thick: f32, color: Color); // Draw spline: Catmull-Rom, minimum 4 points
extern proc DrawSplineBezierQuadratic(points: &Vector2, pointCount: i32, thick: f32, color: Color); // Draw spline: Quadratic Bezier, minimum 3 points (1 control point): [p1, p3: c2,, c4...]
extern proc DrawSplineBezierCubic(points: &Vector2, pointCount: i32, thick: f32, color: Color); // Draw spline: Cubic Bezier, minimum 4 points (2 control points): [p1, c3: c2,, c5: p4,, c6...]
extern proc DrawSplineSegmentLinear(p1: Vector2, p2: Vector2, thick: f32, color: Color); // Draw spline segment: Linear, 2 points
extern proc DrawSplineSegmentBasis(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: f32, color: Color); // Draw spline segment: B-Spline, 4 points
extern proc DrawSplineSegmentCatmullRom(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: f32, color: Color); // Draw spline segment: Catmull-Rom, 4 points
extern proc DrawSplineSegmentBezierQuadratic(p1: Vector2, c2: Vector2, p3: Vector2, thick: f32, color: Color); // Draw spline segment: Quadratic Bezier, points: 2, 1 control point
extern proc DrawSplineSegmentBezierCubic(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, thick: f32, color: Color); // Draw spline segment: Cubic Bezier, points: 2, 2 control points

// Spline segment point evaluation functions, for a given t [0.0f .. 1.0f]
extern proc GetSplinePointLinear(startPos: Vector2, endPos: Vector2, t: f32) -> Vector2; // Get (evaluate) spline point: Linear
extern proc GetSplinePointBasis(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: f32) -> Vector2; // Get (evaluate) spline point: B-Spline
extern proc GetSplinePointCatmullRom(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: f32) -> Vector2; // Get (evaluate) spline point: Catmull-Rom
extern proc GetSplinePointBezierQuad(p1: Vector2, c2: Vector2, p3: Vector2, t: f32) -> Vector2; // Get (evaluate) spline point: Quadratic Bezier
extern proc GetSplinePointBezierCubic(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, t: f32) -> Vector2; // Get (evaluate) spline point: Cubic Bezier

// Basic shapes collision detection functions
extern proc CheckCollisionRecs(rec1: Rectangle, rec2: Rectangle) -> bool; // Check collision between two rectangles
extern proc CheckCollisionCircles(center1: Vector2, radius1: f32, center2: Vector2, radius2: f32) -> bool; // Check collision between two circles
extern proc CheckCollisionCircleRec(center: Vector2, radius: f32, rec: Rectangle) -> bool; // Check collision between circle and rectangle
extern proc CheckCollisionCircleLine(center: Vector2, radius: f32, p1: Vector2, p2: Vector2) -> bool; // Check if circle collides with a line created betweeen two points [p1] and [p2]
extern proc CheckCollisionPointRec(point: Vector2, rec: Rectangle) -> bool; // Check if point is inside rectangle
extern proc CheckCollisionPointCircle(point: Vector2, center: Vector2, radius: f32) -> bool; // Check if point is inside circle
extern proc CheckCollisionPointTriangle(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) -> bool; // Check if point is inside a triangle
extern proc CheckCollisionPointLine(point: Vector2, p1: Vector2, p2: Vector2, threshold: i32) -> bool; // Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]
extern proc CheckCollisionPointPoly(point: Vector2, points: &Vector2, pointCount: i32) -> bool; // Check if point is within a polygon described by array of vertices
extern proc CheckCollisionLines(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: &Vector2) -> bool; // Check the collision between two lines defined by two points each, returns collision point by reference
extern proc GetCollisionRec(rec1: Rectangle, rec2: Rectangle) -> Rectangle; // Get collision rectangle for two rectangles collision

//------------------------------------------------------------------------------------
// Texture Loading and Drawing Functions (Module: textures)
//------------------------------------------------------------------------------------

// Image loading functions
// NOTE: These functions do not require GPU access
extern proc LoadImage(fileName: &i8) -> Image; // Load image from file into CPU memory (RAM)
extern proc LoadImageRaw(fileName: &i8, width: i32, height: i32, format: i32, headerSize: i32) -> Image; // Load image from RAW file data
extern proc LoadImageAnim(fileName: &i8, frames: &i32) -> Image; // Load image sequence from file (frames appended to image.data)
extern proc LoadImageAnimFromMemory(fileType: &i8, fileData: &u8, dataSize: i32, frames: &i32) -> Image; // Load image sequence from memory buffer
extern proc LoadImageFromMemory(fileType: &i8, fileData: &u8, dataSize: i32) -> Image; // Load image from memory buffer, fileType refers to extension: i.e. '.png'
extern proc LoadImageFromTexture(texture: Texture2D) -> Image; // Load image from GPU texture data
extern proc LoadImageFromScreen() -> Image; // Load image from screen buffer and (screenshot)
extern proc IsImageValid(image: Image) -> bool; // Check if an image is valid (data and parameters)
extern proc UnloadImage(image: Image); // Unload image from CPU memory (RAM)
extern proc ExportImage(image: Image, fileName: &i8) -> bool; // Export image data to file, returns true on success
extern proc ExportImageToMemory(image: Image, fileType: &i8, fileSize: &i32) -> &u8; // Export image to memory buffer
extern proc ExportImageAsCode(image: Image, fileName: &i8) -> bool; // Export image as code file defining an array of bytes, returns true on success

// Image generation functions
extern proc GenImageColor(width: i32, height: i32, color: Color) -> Image; // Generate image: plain color
extern proc GenImageGradientLinear(width: i32, height: i32, direction: i32, start: Color, end: Color) -> Image; // Generate image: linear gradient, direction in degrees [0..360], 0=Vertical gradient
extern proc GenImageGradientRadial(width: i32, height: i32, density: f32, inner: Color, outer: Color) -> Image; // Generate image: radial gradient
extern proc GenImageGradientSquare(width: i32, height: i32, density: f32, inner: Color, outer: Color) -> Image; // Generate image: square gradient
extern proc GenImageChecked(width: i32, height: i32, checksX: i32, checksY: i32, col1: Color, col2: Color) -> Image; // Generate image: checked
extern proc GenImageWhiteNoise(width: i32, height: i32, factor: f32) -> Image; // Generate image: white noise
extern proc GenImagePerlinNoise(width: i32, height: i32, offsetX: i32, offsetY: i32, scale: f32) -> Image; // Generate image: perlin noise
extern proc GenImageCellular(width: i32, height: i32, tileSize: i32) -> Image; // Generate image: cellular algorithm, bigger tileSize means bigger cells
extern proc GenImageText(width: i32, height: i32, text: &i8) -> Image; // Generate image: grayscale image from text data

// Image manipulation functions
extern proc ImageCopy(image: Image) -> Image; // Create an image duplicate (useful for transformations)
extern proc ImageFromImage(image: Image, rec: Rectangle) -> Image; // Create an image from another image piece
extern proc ImageFromChannel(image: Image, selectedChannel: i32) -> Image; // Create an image from a selected channel of another image (GRAYSCALE)
extern proc ImageText(text: &i8, fontSize: i32, color: Color) -> Image; // Create an image from text (font: default)
extern proc ImageTextEx(font: Font, text: &i8, fontSize: f32, spacing: f32, tint: Color) -> Image; // Create an image from text (custom sprite font)
extern proc ImageFormat(image: &Image, newFormat: i32); // Convert image data to desired format
extern proc ImageToPOT(image: &Image, fill: Color); // Convert image to POT (power-of-two)
extern proc ImageCrop(image: &Image, crop: Rectangle); // Crop an image to a defined rectangle
extern proc ImageAlphaCrop(image: &Image, threshold: f32); // Crop image depending on alpha value
extern proc ImageAlphaClear(image: &Image, color: Color, threshold: f32); // Clear alpha channel to desired color
extern proc ImageAlphaMask(image: &Image, alphaMask: Image); // Apply alpha mask to image
extern proc ImageAlphaPremultiply(image: &Image); // Premultiply alpha channel
extern proc ImageBlurGaussian(image: &Image, blurSize: i32); // Apply Gaussian blur using a box blur approximation
extern proc ImageKernelConvolution(image: &Image, kernel: &f32, kernelSize: i32); // Apply custom square convolution kernel to image
extern proc ImageResize(image: &Image, newWidth: i32, newHeight: i32); // Resize image (Bicubic scaling algorithm)
extern proc ImageResizeNN(image: &Image, newWidth: i32,newHeight: i32); // Resize image (Nearest-Neighbor scaling algorithm)
extern proc ImageResizeCanvas(image: &Image, newWidth: i32, newHeight: i32, offsetX: i32, offsetY: i32, fill: Color); // Resize canvas and fill with color
extern proc ImageMipmaps(image: &Image); // Compute all mipmap levels for a provided image
extern proc ImageDither(image: &Image, rBpp: i32, gBpp: i32, bBpp: i32, aBpp: i32); // Dither image data to 16bpp or lower (dithering: Floyd-Steinberg)
extern proc ImageFlipVertical(image: &Image); // Flip image vertically
extern proc ImageFlipHorizontal(image: &Image); // Flip image horizontally
extern proc ImageRotate(image: &Image, degrees: i32); // Rotate image by input angle in degrees (-359 to 359)
extern proc ImageRotateCW(image: &Image); // Rotate image clockwise 90deg
extern proc ImageRotateCCW(image: &Image); // Rotate image counter-clockwise 90deg
extern proc ImageColorTint(image: &Image, color: Color); // Modify image color: tint
extern proc ImageColorInvert(image: &Image); // Modify image color: invert
extern proc ImageColorGrayscale(image: &Image); // Modify image color: grayscale
extern proc ImageColorContrast(image: &Image, contrast: f32); // Modify image color: contrast (-100 to 100)
extern proc ImageColorBrightness(image: &Image, brightness: i32); // Modify image color: brightness (-255 to 255)
extern proc ImageColorReplace(image: &Image, color: Color, replace: Color); // Modify image color: replace color
extern proc LoadImageColors(image: Image) -> &Color; // Load color data from image as a Color array (RGBA - 32bit)
extern proc LoadImagePalette(image: Image, maxPaletteSize: i32, colorCount: &i32) -> &Color; // Load colors palette from image as a Color array (RGBA - 32bit)
extern proc UnloadImageColors(colors: &Color); // Unload color data loaded with LoadImageColors()
extern proc UnloadImagePalette(colors: &Color); // Unload colors palette loaded with LoadImagePalette()
extern proc GetImageAlphaBorder(image: Image, threshold: f32) -> Rectangle; // Get image alpha border rectangle
extern proc GetImageColor(image: Image, x: i32, y: i32) -> Color; // Get image pixel color at (y: x,) position

// Image drawing functions
// NOTE: Image software-rendering functions (CPU)
extern proc ImageClearBackground(dst: &Image, color: Color); // Clear image background with given color
extern proc ImageDrawPixel(dst: &Image, posX: i32, posY: i32, color: Color); // Draw pixel within an image
extern proc ImageDrawPixelV(dst: &Image, position: Vector2, color: Color); // Draw pixel within an image (version: Vector)
extern proc ImageDrawLine(dst: &Image, startPosX: i32, startPosY: i32, endPosX: i32, endPosY: i32, color: Color); // Draw line within an image
extern proc ImageDrawLineV(dst: &Image, start: Vector2, end: Vector2, color: Color); // Draw line within an image (version: Vector)
extern proc ImageDrawLineEx(dst: &Image, start: Vector2, end: Vector2, thick: i32, color: Color); // Draw a line defining thickness within an image
extern proc ImageDrawCircle(dst: &Image, centerX: i32, centerY: i32, radius: i32, color: Color); // Draw a filled circle within an image
extern proc ImageDrawCircleV(dst: &Image, center: Vector2, radius: i32, color: Color); // Draw a filled circle within an image (version: Vector)
extern proc ImageDrawCircleLines(dst: &Image, centerX: i32, centerY: i32, radius: i32, color: Color); // Draw circle outline within an image
extern proc ImageDrawCircleLinesV(dst: &Image, center: Vector2, radius: i32, color: Color); // Draw circle outline within an image (version: Vector)
extern proc ImageDrawRectangle(dst: &Image, posX: i32, posY: i32, width: i32, height: i32, color: Color); // Draw rectangle within an image
extern proc ImageDrawRectangleV(dst: &Image, position: Vector2, size: Vector2, color: Color); // Draw rectangle within an image (version: Vector)
extern proc ImageDrawRectangleRec(dst: &Image, rec: Rectangle, color: Color); // Draw rectangle within an image
extern proc ImageDrawRectangleLines(dst: &Image, rec: Rectangle, thick: i32, color: Color); // Draw rectangle lines within an image
extern proc ImageDrawTriangle(dst: &Image, v1: Vector2, v2: Vector2, v3: Vector2, color: Color); // Draw triangle within an image
extern proc ImageDrawTriangleEx(dst: &Image, v1: Vector2, v2: Vector2, v3: Vector2, c1: Color, c2: Color, c3: Color); // Draw triangle with interpolated colors within an image
extern proc ImageDrawTriangleLines(dst: &Image, v1: Vector2, v2: Vector2, v3: Vector2, color: Color); // Draw triangle outline within an image
extern proc ImageDrawTriangleFan(dst: &Image, points: &Vector2, pointCount: i32, color: Color); // Draw a triangle fan defined by points within an image (first vertex is the center)
extern proc ImageDrawTriangleStrip(dst: &Image, points: &Vector2, pointCount: i32, color: Color); // Draw a triangle strip defined by points within an image
extern proc ImageDraw(dst: &Image, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color); // Draw a source image within a destination image (tint applied to source)
extern proc ImageDrawText(dst: &Image, text: &i8, posX: i32, posY: i32, fontSize: i32, color: Color); // Draw text (using default font) within an image (destination)
extern proc ImageDrawTextEx(dst: &Image, font: Font, text: &i8, position: Vector2, fontSize: f32, spacing: f32, tint: Color); // Draw text (custom sprite font) within an image (destination)

// Texture loading functions
// NOTE: These functions require GPU access
extern proc LoadTexture(fileName: &i8) -> Texture2D; // Load texture from file into GPU memory (VRAM)
extern proc LoadTextureFromImage(image: Image) -> Texture2D; // Load texture from image data
extern proc LoadTextureCubemap(image: Image, layout: i32) -> TextureCubemap; // Load cubemap from image, multiple image cubemap layouts supported
extern proc LoadRenderTexture(width: i32, height: i32) -> RenderTexture2D; // Load texture for rendering (framebuffer)
extern proc IsTextureValid(texture: Texture2D) -> bool; // Check if a texture is valid (loaded in GPU)
extern proc UnloadTexture(texture: Texture2D); // Unload texture from GPU memory (VRAM)
extern proc IsRenderTextureValid(target: RenderTexture2D) -> bool; // Check if a render texture is valid (loaded in GPU)
extern proc UnloadRenderTexture(target: RenderTexture2D); // Unload render texture from GPU memory (VRAM)
extern proc UpdateTexture(texture: Texture2D, pixels: &unit); // Update GPU texture with new data
extern proc UpdateTextureRec(texture: Texture2D, rec: Rectangle, pixels: &unit); // Update GPU texture rectangle with new data

// Texture configuration functions
extern proc GenTextureMipmaps(texture: &Texture2D); // Generate GPU mipmaps for a texture
extern proc SetTextureFilter(texture: Texture2D, filter: i32); // Set texture scaling filter mode
extern proc SetTextureWrap(texture: Texture2D, wrap: i32); // Set texture wrapping mode

// Texture drawing functions
extern proc DrawTexture(texture: Texture2D, posX: i32, posY: i32, tint: Color); // Draw a Texture2D
extern proc DrawTextureV(texture: Texture2D, position: Vector2, tint: Color); // Draw a Texture2D with position defined as Vector2
extern proc DrawTextureEx(texture: Texture2D, position: Vector2, rotation: f32, scale: f32, tint: Color); // Draw a Texture2D with extended parameters
extern proc DrawTextureRec(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color); // Draw a part of a texture defined by a rectangle
extern proc DrawTexturePro(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color); // Draw a part of a texture defined by a rectangle with 'pro' parameters
extern proc DrawTextureNPatch(texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color); // Draws a texture (or part of it) that stretches or shrinks nicely

// Color/pixel related functions
extern proc ColorIsEqual(col1: Color, col2: Color) -> bool; // Check if two colors are equal
extern proc Fade(color: Color, alpha: f32) -> Color; // Get color with alpha applied, alpha goes from 0.0f to 1.0f
extern proc ColorToInt(color: Color) -> i32; // Get hexadecimal value for a Color (0xRRGGBBAA)
extern proc ColorNormalize(color: Color) -> Vector4; // Get Color normalized as f32 [0..1]
extern proc ColorFromNormalized(normalized: Vector4) -> Color; // Get Color from normalized values [0..1]
extern proc ColorToHSV(color: Color) -> Vector3; // Get HSV values for a Color, hue [0..360], saturation/value [0..1]
extern proc ColorFromHSV(hue: f32, saturation: f32, value: f32) -> Color; // Get a Color from HSV values, hue [0..360], saturation/value [0..1]
extern proc ColorTint(color: Color, tint: Color) -> Color; // Get color multiplied with another color
extern proc ColorBrightness(color: Color, factor: f32) -> Color; // Get color with brightness correction, brightness factor goes from -1.0f to 1.0f
extern proc ColorContrast(color: Color, contrast: f32) -> Color; // Get color with contrast correction, contrast values between -1.0f and 1.0f
extern proc ColorAlpha(color: Color, alpha: f32) -> Color; // Get color with alpha applied, alpha goes from 0.0f to 1.0f
extern proc ColorAlphaBlend(dst: Color, src: Color, tint: Color) -> Color; // Get src alpha-blended into dst color with tint
extern proc ColorLerp(color1: Color, color2: Color, factor: f32) -> Color; // Get color lerp interpolation between two colors, factor [0.0f..1.0f]
extern proc GetColor(hexValue: u32) -> Color; // Get Color structure from hexadecimal value
extern proc GetPixelColor(srcPtr: &unit, format: i32) -> Color; // Get Color from a source pixel pointer of certain format
extern proc SetPixelColor(dstPtr: &unit, color: Color, format: i32); // Set color formatted into destination pixel pointer
extern proc GetPixelDataSize(width: i32, height: i32, format: i32) -> i32; // Get pixel data size in bytes for certain format

//------------------------------------------------------------------------------------
// Font Loading and Text Drawing Functions (Module: text)
//------------------------------------------------------------------------------------

// Font loading/unloading functions
extern proc GetFontDefault() -> Font; // Get the default Font
extern proc LoadFont(fileName: &i8) -> Font; // Load font from file into GPU memory (VRAM)
extern proc LoadFontEx(fileName: &i8, fontSize: i32, codepoints: &i32, codepointCount: i32) -> Font; // Load font from file with extended parameters, use NULL for codepoints and 0 for codepointCount to load the default character set, font size is provided in pixels height
extern proc LoadFontFromImage(image: Image, key: Color, firstChar: i32) -> Font; // Load font from Image (style: XNA)
extern proc LoadFontFromMemory(fileType: &i8, fileData: &u8, dataSize: i32, fontSize: i32, codepoints: &i32, codepointCount: i32) -> Font; // Load font from memory buffer, fileType refers to extension: i.e. '.ttf'
extern proc IsFontValid(font: Font) -> bool; // Check if a font is valid (font data loaded, WARNING: GPU texture not checked)
extern proc LoadFontData(fileData: &u8, dataSize: i32, fontSize: i32, codepoints: &i32, codepointCount: i32, type_: i32) -> &GlyphInfo; // Load font data for further use
extern proc GenImageFontAtlas(glyphs: &GlyphInfo, glyphRecs: &&Rectangle, glyphCount: i32, fontSize: i32, padding: i32, packMethod: i32) -> Image; // Generate image font atlas using chars info
extern proc UnloadFontData(glyphs: &GlyphInfo, glyphCount: i32); // Unload font chars info data (RAM)
extern proc UnloadFont(font: Font); // Unload font from GPU memory (VRAM)
extern proc ExportFontAsCode(font: Font, fileName: &i8) -> bool; // Export font as code file, returns true on success

// Text drawing functions
extern proc DrawFPS(posX: i32, posY: i32); // Draw current FPS
extern proc DrawText(text: &i8, posX: i32, posY: i32, fontSize: i32, color: Color); // Draw text (using default font)
extern proc DrawTextEx(font: Font, text: &i8, position: Vector2, fontSize: f32, spacing: f32, tint: Color); // Draw text using font and additional parameters
extern proc DrawTextPro(font: Font, text: &i8, position: Vector2, origin: Vector2, rotation: f32, fontSize: f32, spacing: f32, tint: Color); // Draw text using Font and pro parameters (rotation)
extern proc DrawTextCodepoint(font: Font, codepoint: i32, position: Vector2, fontSize: f32, tint: Color); // Draw one character (codepoint)
extern proc DrawTextCodepoints(font: Font, codepoints: &i32, codepointCount: i32, position: Vector2, fontSize: f32, spacing: f32, tint: Color); // Draw multiple character (codepoint)

// Text font info functions
extern proc SetTextLineSpacing(spacing: i32); // Set vertical line spacing when drawing with line-breaks
extern proc MeasureText(text: &i8, fontSize: i32) -> i32; // Measure string width for default font
extern proc MeasureTextEx(font: Font, text: &i8, fontSize: f32, spacing: f32) -> Vector2; // Measure string size for Font
extern proc GetGlyphIndex(font: Font, codepoint: i32) -> i32; // Get glyph index position in font for a codepoint (character: unicode), fallback to '?' if not found
extern proc GetGlyphInfo(font: Font, codepoint: i32) -> GlyphInfo; // Get glyph font info data for a codepoint (character: unicode), fallback to '?' if not found
extern proc GetGlyphAtlasRec(font: Font, codepoint: i32) -> Rectangle; // Get glyph rectangle in font atlas for a codepoint (character: unicode), fallback to '?' if not found

// Text codepoints management functions (characters: unicode)
extern proc LoadUTF8(codepoints: &i32, length: i32) -> &i8; // Load UTF-8 text encoded from codepoints array
extern proc UnloadUTF8(text: &i8); // Unload UTF-8 text encoded from codepoints array
extern proc LoadCodepoints(text: &i8, count: &i32) -> &i32; // Load all codepoints from a UTF-8 text string, codepoints count returned by parameter
extern proc UnloadCodepoints(codepoints: &i32); // Unload codepoints data from memory
extern proc GetCodepointCount(text: &i8) -> i32; // Get total number of codepoints in a UTF-8 encoded string
extern proc GetCodepoint(text: &i8, codepointSize: &i32) -> i32; // Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
extern proc GetCodepointNext(text: &i8, codepointSize: &i32) -> i32; // Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
extern proc GetCodepointPrevious(text: &i8, codepointSize: &i32) -> i32; // Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
extern proc CodepointToUTF8(codepoint: i32, utf8Size: &i32) -> &i8; // Encode one codepoint into UTF-8 byte array (array length returned as parameter)

// Text strings management functions (no UTF-8 strings, only byte chars)
// NOTE: Some strings allocate memory internally for returned strings, just be careful!
extern proc TextCopy(dst: &i8, src: &i8) -> i32; // Copy one string to another, returns bytes copied
extern proc TextIsEqual(text1: &i8, text2: &i8) -> bool; // Check if two text string are equal
extern proc TextLength(text: &i8) -> u32; // Get text length, checks for '\0' ending
//extern proc TextFormat(text: &i8, ...) -> &i8; // Text formatting with variables (style: sprintf())
extern proc TextSubtext(text: &i8, position: i32, length: i32) -> &i8; // Get a piece of a text string
extern proc TextReplace(text: &i8, replace: &i8, by: &i8) -> &i8; // Replace text string (WARNING: memory must be freed!)
extern proc TextInsert(text: &i8, insert: &i8, position: i32) -> &i8; // Insert text in a position (WARNING: memory must be freed!)
extern proc TextJoin(textList: &&i8, count: i32, delimiter: &i8) -> &i8; // Join text strings with delimiter
extern proc TextSplit(text: &i8, delimiter: i8, count: &i32) -> &&i8;                 // Split text into multiple strings
extern proc TextAppend(text: &i8, append: &i8, position: &i32); // Append text at specific position and move cursor!
extern proc TextFindIndex(text: &i8, find: &i8) -> i32; // Find first text occurrence within a string
extern proc TextToUpper(text: &i8) -> &i8; // Get upper case version of provided string
extern proc TextToLower(text: &i8) -> &i8; // Get lower case version of provided string
extern proc TextToPascal(text: &i8) -> &i8; // Get Pascal case notation version of provided string
extern proc TextToSnake(text: &i8) -> &i8; // Get Snake case notation version of provided string
extern proc TextToCamel(text: &i8) -> &i8; // Get Camel case notation version of provided string

extern proc TextToInteger(text: &i8) -> i32; // Get integer value from text (negative values not supported)
extern proc TextToFloat(text: &i8) -> f32; // Get f32 value from text (negative values not supported)

//------------------------------------------------------------------------------------
// Basic 3d Shapes Drawing Functions (Module: models)
//------------------------------------------------------------------------------------

// Basic geometric 3D shapes drawing functions
extern proc DrawLine3D(startPos: Vector3, endPos: Vector3, color: Color); // Draw a line in 3D world space
extern proc DrawPoint3D(position: Vector3, color: Color); // Draw a point in 3D space, actually a small line
extern proc DrawCircle3D(center: Vector3, radius: f32, rotationAxis: Vector3, rotationAngle: f32, color: Color); // Draw a circle in 3D world space
extern proc DrawTriangle3D(v1: Vector3, v2: Vector3, v3: Vector3, color: Color); // Draw a color-filled triangle (vertex in counter-clockwise order!)
extern proc DrawTriangleStrip3D(points: &Vector3, pointCount: i32, color: Color); // Draw a triangle strip defined by points
extern proc DrawCube(position: Vector3, width: f32, height: f32, length: f32, color: Color); // Draw cube
extern proc DrawCubeV(position: Vector3, size: Vector3, color: Color); // Draw cube (version: Vector)
extern proc DrawCubeWires(position: Vector3, width: f32, height: f32, length: f32, color: Color); // Draw cube wires
extern proc DrawCubeWiresV(position: Vector3, size: Vector3, color: Color); // Draw cube wires (version: Vector)
extern proc DrawSphere(centerPos: Vector3, radius: f32, color: Color); // Draw sphere
extern proc DrawSphereEx(centerPos: Vector3, radius: f32, rings: i32, slices: i32, color: Color); // Draw sphere with extended parameters
extern proc DrawSphereWires(centerPos: Vector3, radius: f32, rings: i32, slices: i32, color: Color); // Draw sphere wires
extern proc DrawCylinder(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: i32, color: Color); // Draw a cylinder/cone
extern proc DrawCylinderEx(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: i32, color: Color); // Draw a cylinder with base at startPos and top at endPos
extern proc DrawCylinderWires(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: i32, color: Color); // Draw a cylinder/cone wires
extern proc DrawCylinderWiresEx(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: i32, color: Color); // Draw a cylinder wires with base at startPos and top at endPos
extern proc DrawCapsule(startPos: Vector3, endPos: Vector3, radius: f32, slices: i32, rings: i32, color: Color); // Draw a capsule with the center of its sphere caps at startPos and endPos
extern proc DrawCapsuleWires(startPos: Vector3, endPos: Vector3, radius: f32, slices: i32, rings: i32, color: Color); // Draw capsule wireframe with the center of its sphere caps at startPos and endPos
extern proc DrawPlane(centerPos: Vector3, size: Vector2, color: Color); // Draw a plane XZ
extern proc DrawRay(ray: Ray, color: Color); // Draw a ray line
extern proc DrawGrid(slices: i32, spacing: f32); // Draw a grid (centered at (0, 0, 0))

//------------------------------------------------------------------------------------
// Model 3d Loading and Drawing Functions (Module: models)
//------------------------------------------------------------------------------------

// Model management functions
extern proc LoadModel(fileName: &i8) -> Model; // Load model from files (meshes and materials)
extern proc LoadModelFromMesh(mesh: Mesh) -> Model; // Load model from generated mesh (material: default)
extern proc IsModelValid(model: Model) -> bool; // Check if a model is valid (loaded in GPU, VAO/VBOs)
extern proc UnloadModel(model: Model); // Unload model (meshes: including) from memory (RAM and/or VRAM)
extern proc GetModelBoundingBox(model: Model) -> BoundingBox; // Compute model bounding box limits (considers all meshes)

// Model drawing functions
extern proc DrawModel(model: Model, position: Vector3, scale: f32, tint: Color); // Draw a model (with texture if set)
extern proc DrawModelEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color); // Draw a model with extended parameters
extern proc DrawModelWires(model: Model, position: Vector3, scale: f32, tint: Color); // Draw a model wires (with texture if set)
extern proc DrawModelWiresEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color); // Draw a model wires (with texture if set) with extended parameters
extern proc DrawModelPoints(model: Model, position: Vector3, scale: f32, tint: Color); // Draw a model as points
extern proc DrawModelPointsEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color); // Draw a model as points with extended parameters
extern proc DrawBoundingBox(box: BoundingBox, color: Color); // Draw bounding box (wires)
extern proc DrawBillboard(camera: Camera, texture: Texture2D, position: Vector3, scale: f32, tint: Color); // Draw a billboard texture
extern proc DrawBillboardRec(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color); // Draw a billboard texture defined by source
extern proc DrawBillboardPro(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: f32, tint: Color); // Draw a billboard texture defined by source and rotation

// Mesh management functions
extern proc UploadMesh(mesh: &Mesh, dynamic: bool); // Upload mesh vertex data in GPU and provide VAO/VBO ids
extern proc UpdateMeshBuffer(mesh: Mesh, index: i32, data: &unit, dataSize: i32, offset: i32); // Update mesh vertex data in GPU for a specific buffer index
extern proc UnloadMesh(mesh: Mesh); // Unload mesh data from CPU and GPU
extern proc DrawMesh(mesh: Mesh, material: Material, transform: Matrix); // Draw a 3d mesh with material and transform
extern proc DrawMeshInstanced(mesh: Mesh, material: Material, transforms: &Matrix, instances: i32); // Draw multiple mesh instances with material and different transforms
extern proc GetMeshBoundingBox(mesh: Mesh) -> BoundingBox; // Compute mesh bounding box limits
extern proc GenMeshTangents(mesh: &Mesh); // Compute mesh tangents
extern proc ExportMesh(mesh: Mesh, fileName: &i8) -> bool; // Export mesh data to file, returns true on success
extern proc ExportMeshAsCode(mesh: Mesh, fileName: &i8) -> bool; // Export mesh as code file (.h) defining multiple arrays of vertex attributes

// Mesh generation functions
extern proc GenMeshPoly(sides: i32, radius: f32) -> Mesh; // Generate polygonal mesh
extern proc GenMeshPlane(width: f32, length: f32, resX: i32, resZ: i32) -> Mesh; // Generate plane mesh (subdivisions: with)
extern proc GenMeshCube(width: f32, height: f32, length: f32) -> Mesh; // Generate cuboid mesh
extern proc GenMeshSphere(radius: f32, rings: i32, slices: i32) -> Mesh; // Generate sphere mesh (sphere: standard)
extern proc GenMeshHemiSphere(radius: f32, rings: i32, slices: i32) -> Mesh; // Generate half-sphere mesh (no bottom cap)
extern proc GenMeshCylinder(radius: f32, height: f32, slices: i32) -> Mesh; // Generate cylinder mesh
extern proc GenMeshCone(radius: f32, height: f32, slices: i32) -> Mesh; // Generate cone/pyramid mesh
extern proc GenMeshTorus(radius: f32, size: f32, radSeg: i32, sides: i32) -> Mesh; // Generate torus mesh
extern proc GenMeshKnot(radius: f32, size: f32, radSeg: i32, sides: i32) -> Mesh; // Generate trefoil knot mesh
extern proc GenMeshHeightmap(heightmap: Image, size: Vector3) -> Mesh; // Generate heightmap mesh from image data
extern proc GenMeshCubicmap(cubicmap: Image, cubeSize: Vector3) -> Mesh; // Generate cubes-based map mesh from image data

// Material loading/unloading functions
extern proc LoadMaterials(fileName: &i8, materialCount: &i32) -> &Material; // Load materials from model file
extern proc LoadMaterialDefault() -> Material; // Load default material (Supports: DIFFUSE, SPECULAR, maps: NORMAL)
extern proc IsMaterialValid(material: Material) -> bool; // Check if a material is valid (assigned: shader, map textures loaded in GPU)
extern proc UnloadMaterial(material: Material); // Unload material from GPU memory (VRAM)
extern proc SetMaterialTexture(material: &Material, mapType: i32, texture: Texture2D); // Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...)
extern proc SetModelMeshMaterial(model: &Model, meshId: i32, materialId: i32); // Set material for a mesh

// Model animations loading/unloading functions
extern proc LoadModelAnimations(fileName: &i8, animCount: &i32) -> &ModelAnimation; // Load model animations from file
extern proc UpdateModelAnimation(model: Model, anim: ModelAnimation, frame: i32); // Update model animation pose (CPU)
extern proc UpdateModelAnimationBones(model: Model, anim: ModelAnimation, frame: i32); // Update model animation mesh bone matrices (skinning: GPU)
extern proc UnloadModelAnimation(anim: ModelAnimation); // Unload animation data
extern proc UnloadModelAnimations(animations: &ModelAnimation, animCount: i32); // Unload animation array data
extern proc IsModelAnimationValid(model: Model, anim: ModelAnimation) -> bool; // Check model animation skeleton match

// Collision detection functions
extern proc CheckCollisionSpheres(center1: Vector3, radius1: f32, center2: Vector3, radius2: f32) -> bool; // Check collision between two spheres
extern proc CheckCollisionBoxes(box1: BoundingBox, box2: BoundingBox) -> bool; // Check collision between two bounding boxes
extern proc CheckCollisionBoxSphere(box: BoundingBox, center: Vector3, radius: f32) -> bool; // Check collision between box and sphere
extern proc GetRayCollisionSphere(ray: Ray, center: Vector3, radius: f32) -> RayCollision; // Get collision info between ray and sphere
extern proc GetRayCollisionBox(ray: Ray, box: BoundingBox) -> RayCollision; // Get collision info between ray and box
extern proc GetRayCollisionMesh(ray: Ray, mesh: Mesh, transform: Matrix) -> RayCollision; // Get collision info between ray and mesh
extern proc GetRayCollisionTriangle(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3) -> RayCollision; // Get collision info between ray and triangle
extern proc GetRayCollisionQuad(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3) -> RayCollision; // Get collision info between ray and quad

//------------------------------------------------------------------------------------
// Audio Loading and Playing Functions (Module: audio)
//------------------------------------------------------------------------------------
type AudioCallback = proc(&unit, u32);

// Audio device management functions
extern proc InitAudioDevice(); // Initialize audio device and context
extern proc CloseAudioDevice(); // Close the audio device and context
extern proc IsAudioDeviceReady() -> bool; // Check if audio device has been initialized successfully
extern proc SetMasterVolume(volume: f32); // Set master volume (listener)
extern proc GetMasterVolume() -> f32; // Get master volume (listener)

// Wave/Sound loading/unloading functions
extern proc LoadWave(fileName: &i8) -> Wave; // Load wave data from file
extern proc LoadWaveFromMemory(fileType: &i8, fileData: &u8, dataSize: i32) -> Wave; // Load wave from memory buffer, fileType refers to extension: i.e. '.wav'
extern proc IsWaveValid(wave: Wave) -> bool; // Checks if wave data is valid (data loaded and parameters)
extern proc LoadSound(fileName: &i8) -> Sound; // Load sound from file
extern proc LoadSoundFromWave(wave: Wave) -> Sound; // Load sound from wave data
extern proc LoadSoundAlias(source: Sound) -> Sound; // Create a new sound that shares the same sample data as the source sound, does not own the sound data
extern proc IsSoundValid(sound: Sound) -> bool; // Checks if a sound is valid (data loaded and buffers initialized)
extern proc UpdateSound(sound: Sound, data: &unit, sampleCount: i32); // Update sound buffer with new data
extern proc UnloadWave(wave: Wave); // Unload wave data
extern proc UnloadSound(sound: Sound); // Unload sound
extern proc UnloadSoundAlias(alias: Sound); // Unload a sound alias (does not deallocate sample data)
extern proc ExportWave(wave: Wave, fileName: &i8) -> bool; // Export wave data to file, returns true on success
extern proc ExportWaveAsCode(wave: Wave, fileName: &i8) -> bool; // Export wave sample data to code (.h), returns true on success

// Wave/Sound management functions
extern proc PlaySound(sound: Sound); // Play a sound
extern proc StopSound(sound: Sound); // Stop playing a sound
extern proc PauseSound(sound: Sound); // Pause a sound
extern proc ResumeSound(sound: Sound); // Resume a paused sound
extern proc IsSoundPlaying(sound: Sound) -> bool; // Check if a sound is currently playing
extern proc SetSoundVolume(sound: Sound, volume: f32); // Set volume for a sound (1.0 is max level)
extern proc SetSoundPitch(sound: Sound, pitch: f32); // Set pitch for a sound (1.0 is base level)
extern proc SetSoundPan(sound: Sound, pan: f32); // Set pan for a sound (0.5 is center)
extern proc WaveCopy(wave: Wave) -> Wave; // Copy a wave to a new wave
extern proc WaveCrop(wave: &Wave, initFrame: i32, finalFrame: i32); // Crop a wave to defined frames range
extern proc WaveFormat(wave: &Wave, sampleRate: i32, sampleSize: i32, channels: i32); // Convert wave data to desired format
extern proc LoadWaveSamples(wave: Wave) -> &f32; // Load samples data from wave as a 32bit f32 data array
extern proc UnloadWaveSamples(samples: &f32); // Unload samples data loaded with LoadWaveSamples()

// Music management functions
extern proc LoadMusicStream(fileName: &i8) -> Music; // Load music stream from file
extern proc LoadMusicStreamFromMemory(fileType: &i8, data: &u8, dataSize: i32) -> Music; // Load music stream from data
extern proc IsMusicValid(music: Music) -> bool; // Checks if a music stream is valid (context and buffers initialized)
extern proc UnloadMusicStream(music: Music); // Unload music stream
extern proc PlayMusicStream(music: Music); // Start music playing
extern proc IsMusicStreamPlaying(music: Music) -> bool; // Check if music is playing
extern proc UpdateMusicStream(music: Music); // Updates buffers for music streaming
extern proc StopMusicStream(music: Music); // Stop music playing
extern proc PauseMusicStream(music: Music); // Pause music playing
extern proc ResumeMusicStream(music: Music); // Resume playing paused music
extern proc SeekMusicStream(music: Music, position: f32); // Seek music to a position (seconds: in)
extern proc SetMusicVolume(music: Music, volume: f32); // Set volume for music (1.0 is max level)
extern proc SetMusicPitch(music: Music, pitch: f32); // Set pitch for a music (1.0 is base level)
extern proc SetMusicPan(music: Music, pan: f32); // Set pan for a music (0.5 is center)
extern proc GetMusicTimeLength(music: Music) -> f32; // Get music time length (seconds: in)
extern proc GetMusicTimePlayed(music: Music) -> f32; // Get current music time played (seconds: in)

// AudioStream management functions
extern proc LoadAudioStream(sampleRate: u32, sampleSize: u32, channels: u32) -> AudioStream; // Load audio stream (to stream raw audio pcm data)
extern proc IsAudioStreamValid(stream: AudioStream) -> bool; // Checks if an audio stream is valid (initialized: buffers)
extern proc UnloadAudioStream(stream: AudioStream); // Unload audio stream and free memory
extern proc UpdateAudioStream(stream: AudioStream, data: &unit, frameCount: i32); // Update audio stream buffers with data
extern proc IsAudioStreamProcessed(stream: AudioStream) -> bool; // Check if any audio stream buffers requires refill
extern proc PlayAudioStream(stream: AudioStream); // Play audio stream
extern proc PauseAudioStream(stream: AudioStream); // Pause audio stream
extern proc ResumeAudioStream(stream: AudioStream); // Resume audio stream
extern proc IsAudioStreamPlaying(stream: AudioStream) -> bool; // Check if audio stream is playing
extern proc StopAudioStream(stream: AudioStream); // Stop audio stream
extern proc SetAudioStreamVolume(stream: AudioStream, volume: f32); // Set volume for audio stream (1.0 is max level)
extern proc SetAudioStreamPitch(stream: AudioStream, pitch: f32); // Set pitch for audio stream (1.0 is base level)
extern proc SetAudioStreamPan(stream: AudioStream, pan: f32); // Set pan for audio stream (0.5 is centered)
extern proc SetAudioStreamBufferSizeDefault(size: i32); // Default size for new audio streams
extern proc SetAudioStreamCallback(stream: AudioStream, callback: AudioCallback); // Audio thread callback to request new data

extern proc AttachAudioStreamProcessor(stream: AudioStream, processor: AudioCallback); // Attach audio stream processor to stream, receives the samples as 'f32'
extern proc DetachAudioStreamProcessor(stream: AudioStream, processor: AudioCallback); // Detach audio stream processor from stream

extern proc AttachAudioMixedProcessor(processor: AudioCallback); // Attach audio stream processor to the entire audio pipeline, receives the samples as 'f32'
extern proc DetachAudioMixedProcessor(processor: AudioCallback); // Detach audio stream processor from the entire audio pipeline
